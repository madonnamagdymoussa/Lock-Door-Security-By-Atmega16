
MC1_Final_Project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001d62  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000d8  00800060  00001d62  00001df6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000036  00800138  00800138  00001ece  2**0
                  ALLOC
  3 .stab         00002ee0  00000000  00000000  00001ed0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002518  00000000  00000000  00004db0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 40 09 	jmp	0x1280	; 0x1280 <__vector_3>
      10:	0c 94 a0 08 	jmp	0x1140	; 0x1140 <__vector_4>
      14:	0c 94 69 0a 	jmp	0x14d2	; 0x14d2 <__vector_5>
      18:	0c 94 e9 09 	jmp	0x13d2	; 0x13d2 <__vector_6>
      1c:	0c 94 34 0a 	jmp	0x1468	; 0x1468 <__vector_7>
      20:	0c 94 90 09 	jmp	0x1320	; 0x1320 <__vector_8>
      24:	0c 94 2e 08 	jmp	0x105c	; 0x105c <__vector_9>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 f0 08 	jmp	0x11e0	; 0x11e0 <__vector_19>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d4 e0       	ldi	r29, 0x04	; 4
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 e6       	ldi	r30, 0x62	; 98
      68:	fd e1       	ldi	r31, 0x1D	; 29
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 33       	cpi	r26, 0x38	; 56
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	11 e0       	ldi	r17, 0x01	; 1
      78:	a8 e3       	ldi	r26, 0x38	; 56
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ae 36       	cpi	r26, 0x6E	; 110
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 b6 03 	call	0x76c	; 0x76c <main>
      8a:	0c 94 af 0e 	jmp	0x1d5e	; 0x1d5e <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <UART_init>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <UART_init+0x6>
      98:	cd b7       	in	r28, 0x3d	; 61
      9a:	de b7       	in	r29, 0x3e	; 62
      9c:	9a 83       	std	Y+2, r25	; 0x02
      9e:	89 83       	std	Y+1, r24	; 0x01
      a0:	eb e2       	ldi	r30, 0x2B	; 43
      a2:	f0 e0       	ldi	r31, 0x00	; 0
      a4:	80 81       	ld	r24, Z
      a6:	8e 7f       	andi	r24, 0xFE	; 254
      a8:	80 83       	st	Z, r24
      aa:	eb e2       	ldi	r30, 0x2B	; 43
      ac:	f0 e0       	ldi	r31, 0x00	; 0
      ae:	80 81       	ld	r24, Z
      b0:	8d 7f       	andi	r24, 0xFD	; 253
      b2:	80 83       	st	Z, r24
      b4:	a0 e4       	ldi	r26, 0x40	; 64
      b6:	b0 e0       	ldi	r27, 0x00	; 0
      b8:	e0 e4       	ldi	r30, 0x40	; 64
      ba:	f0 e0       	ldi	r31, 0x00	; 0
      bc:	80 81       	ld	r24, Z
      be:	28 2f       	mov	r18, r24
      c0:	29 7f       	andi	r18, 0xF9	; 249
      c2:	e9 81       	ldd	r30, Y+1	; 0x01
      c4:	fa 81       	ldd	r31, Y+2	; 0x02
      c6:	85 81       	ldd	r24, Z+5	; 0x05
      c8:	88 2f       	mov	r24, r24
      ca:	90 e0       	ldi	r25, 0x00	; 0
      cc:	88 0f       	add	r24, r24
      ce:	99 1f       	adc	r25, r25
      d0:	82 2b       	or	r24, r18
      d2:	8c 93       	st	X, r24
      d4:	a0 e4       	ldi	r26, 0x40	; 64
      d6:	b0 e0       	ldi	r27, 0x00	; 0
      d8:	e0 e4       	ldi	r30, 0x40	; 64
      da:	f0 e0       	ldi	r31, 0x00	; 0
      dc:	80 81       	ld	r24, Z
      de:	28 2f       	mov	r18, r24
      e0:	2f 7c       	andi	r18, 0xCF	; 207
      e2:	e9 81       	ldd	r30, Y+1	; 0x01
      e4:	fa 81       	ldd	r31, Y+2	; 0x02
      e6:	83 81       	ldd	r24, Z+3	; 0x03
      e8:	88 2f       	mov	r24, r24
      ea:	90 e0       	ldi	r25, 0x00	; 0
      ec:	82 95       	swap	r24
      ee:	92 95       	swap	r25
      f0:	90 7f       	andi	r25, 0xF0	; 240
      f2:	98 27       	eor	r25, r24
      f4:	80 7f       	andi	r24, 0xF0	; 240
      f6:	98 27       	eor	r25, r24
      f8:	82 2b       	or	r24, r18
      fa:	8c 93       	st	X, r24
      fc:	a0 e4       	ldi	r26, 0x40	; 64
      fe:	b0 e0       	ldi	r27, 0x00	; 0
     100:	e0 e4       	ldi	r30, 0x40	; 64
     102:	f0 e0       	ldi	r31, 0x00	; 0
     104:	80 81       	ld	r24, Z
     106:	28 2f       	mov	r18, r24
     108:	27 7f       	andi	r18, 0xF7	; 247
     10a:	e9 81       	ldd	r30, Y+1	; 0x01
     10c:	fa 81       	ldd	r31, Y+2	; 0x02
     10e:	84 81       	ldd	r24, Z+4	; 0x04
     110:	88 2f       	mov	r24, r24
     112:	90 e0       	ldi	r25, 0x00	; 0
     114:	88 0f       	add	r24, r24
     116:	99 1f       	adc	r25, r25
     118:	88 0f       	add	r24, r24
     11a:	99 1f       	adc	r25, r25
     11c:	88 0f       	add	r24, r24
     11e:	99 1f       	adc	r25, r25
     120:	82 2b       	or	r24, r18
     122:	8c 93       	st	X, r24
     124:	a0 e4       	ldi	r26, 0x40	; 64
     126:	b0 e0       	ldi	r27, 0x00	; 0
     128:	e0 e4       	ldi	r30, 0x40	; 64
     12a:	f0 e0       	ldi	r31, 0x00	; 0
     12c:	80 81       	ld	r24, Z
     12e:	28 2f       	mov	r18, r24
     130:	2f 7b       	andi	r18, 0xBF	; 191
     132:	e9 81       	ldd	r30, Y+1	; 0x01
     134:	fa 81       	ldd	r31, Y+2	; 0x02
     136:	82 81       	ldd	r24, Z+2	; 0x02
     138:	88 2f       	mov	r24, r24
     13a:	90 e0       	ldi	r25, 0x00	; 0
     13c:	00 24       	eor	r0, r0
     13e:	96 95       	lsr	r25
     140:	87 95       	ror	r24
     142:	07 94       	ror	r0
     144:	96 95       	lsr	r25
     146:	87 95       	ror	r24
     148:	07 94       	ror	r0
     14a:	98 2f       	mov	r25, r24
     14c:	80 2d       	mov	r24, r0
     14e:	82 2b       	or	r24, r18
     150:	8c 93       	st	X, r24
     152:	aa e2       	ldi	r26, 0x2A	; 42
     154:	b0 e0       	ldi	r27, 0x00	; 0
     156:	ea e2       	ldi	r30, 0x2A	; 42
     158:	f0 e0       	ldi	r31, 0x00	; 0
     15a:	80 81       	ld	r24, Z
     15c:	88 60       	ori	r24, 0x08	; 8
     15e:	8c 93       	st	X, r24
     160:	aa e2       	ldi	r26, 0x2A	; 42
     162:	b0 e0       	ldi	r27, 0x00	; 0
     164:	ea e2       	ldi	r30, 0x2A	; 42
     166:	f0 e0       	ldi	r31, 0x00	; 0
     168:	80 81       	ld	r24, Z
     16a:	80 61       	ori	r24, 0x10	; 16
     16c:	8c 93       	st	X, r24
     16e:	a9 e2       	ldi	r26, 0x29	; 41
     170:	b0 e0       	ldi	r27, 0x00	; 0
     172:	e9 81       	ldd	r30, Y+1	; 0x01
     174:	fa 81       	ldd	r31, Y+2	; 0x02
     176:	80 81       	ld	r24, Z
     178:	91 81       	ldd	r25, Z+1	; 0x01
     17a:	8c 93       	st	X, r24
     17c:	a0 e4       	ldi	r26, 0x40	; 64
     17e:	b0 e0       	ldi	r27, 0x00	; 0
     180:	e9 81       	ldd	r30, Y+1	; 0x01
     182:	fa 81       	ldd	r31, Y+2	; 0x02
     184:	80 81       	ld	r24, Z
     186:	91 81       	ldd	r25, Z+1	; 0x01
     188:	89 2f       	mov	r24, r25
     18a:	99 27       	eor	r25, r25
     18c:	8c 93       	st	X, r24
     18e:	0f 90       	pop	r0
     190:	0f 90       	pop	r0
     192:	cf 91       	pop	r28
     194:	df 91       	pop	r29
     196:	08 95       	ret

00000198 <UART_ByteRecieved>:


}

/**************************************************************/
u8_t UART_ByteRecieved(void){
     198:	df 93       	push	r29
     19a:	cf 93       	push	r28
     19c:	cd b7       	in	r28, 0x3d	; 61
     19e:	de b7       	in	r29, 0x3e	; 62

	while (MUART_UCSRA.BITS.Recevie_Complete == 1);
     1a0:	eb e2       	ldi	r30, 0x2B	; 43
     1a2:	f0 e0       	ldi	r31, 0x00	; 0
     1a4:	80 81       	ld	r24, Z
     1a6:	80 78       	andi	r24, 0x80	; 128
     1a8:	88 23       	and	r24, r24
     1aa:	d1 f7       	brne	.-12     	; 0x1a0 <UART_ByteRecieved+0x8>

	return MUART_UDR;
     1ac:	ec e2       	ldi	r30, 0x2C	; 44
     1ae:	f0 e0       	ldi	r31, 0x00	; 0
     1b0:	80 81       	ld	r24, Z

}
     1b2:	cf 91       	pop	r28
     1b4:	df 91       	pop	r29
     1b6:	08 95       	ret

000001b8 <UART_IS_ByteRecieved>:
/**************************************************************/
u8_t UART_IS_ByteRecieved(u8_t *ptr_data){
     1b8:	df 93       	push	r29
     1ba:	cf 93       	push	r28
     1bc:	00 d0       	rcall	.+0      	; 0x1be <UART_IS_ByteRecieved+0x6>
     1be:	0f 92       	push	r0
     1c0:	cd b7       	in	r28, 0x3d	; 61
     1c2:	de b7       	in	r29, 0x3e	; 62
     1c4:	9b 83       	std	Y+3, r25	; 0x03
     1c6:	8a 83       	std	Y+2, r24	; 0x02

	u8_t status =0; /* Default value (nothing recieved) */
     1c8:	19 82       	std	Y+1, r1	; 0x01

	if(MUART_UCSRA.BITS.Recevie_Complete == 1){
     1ca:	eb e2       	ldi	r30, 0x2B	; 43
     1cc:	f0 e0       	ldi	r31, 0x00	; 0
     1ce:	80 81       	ld	r24, Z
     1d0:	80 78       	andi	r24, 0x80	; 128
     1d2:	88 23       	and	r24, r24
     1d4:	41 f0       	breq	.+16     	; 0x1e6 <UART_IS_ByteRecieved+0x2e>

		*ptr_data= MUART_UDR;
     1d6:	ec e2       	ldi	r30, 0x2C	; 44
     1d8:	f0 e0       	ldi	r31, 0x00	; 0
     1da:	80 81       	ld	r24, Z
     1dc:	ea 81       	ldd	r30, Y+2	; 0x02
     1de:	fb 81       	ldd	r31, Y+3	; 0x03
     1e0:	80 83       	st	Z, r24
		status=1;
     1e2:	81 e0       	ldi	r24, 0x01	; 1
     1e4:	89 83       	std	Y+1, r24	; 0x01
	}

	return status;
     1e6:	89 81       	ldd	r24, Y+1	; 0x01

}
     1e8:	0f 90       	pop	r0
     1ea:	0f 90       	pop	r0
     1ec:	0f 90       	pop	r0
     1ee:	cf 91       	pop	r28
     1f0:	df 91       	pop	r29
     1f2:	08 95       	ret

000001f4 <UART_SendByte>:
 *  or wait for TOO LONG time so there is no need to waist that time instead
 *  (UART_IS_ByteRecieved) method is created
 */
/************************************************************************************/

void UART_SendByte(u8_t data){
     1f4:	df 93       	push	r29
     1f6:	cf 93       	push	r28
     1f8:	0f 92       	push	r0
     1fa:	cd b7       	in	r28, 0x3d	; 61
     1fc:	de b7       	in	r29, 0x3e	; 62
     1fe:	89 83       	std	Y+1, r24	; 0x01

	while (MUART_UCSRA.BITS.Data_Register_Empty==0);
     200:	eb e2       	ldi	r30, 0x2B	; 43
     202:	f0 e0       	ldi	r31, 0x00	; 0
     204:	80 81       	ld	r24, Z
     206:	80 72       	andi	r24, 0x20	; 32
     208:	88 23       	and	r24, r24
     20a:	d1 f3       	breq	.-12     	; 0x200 <UART_SendByte+0xc>

	MUART_UDR= data;
     20c:	ec e2       	ldi	r30, 0x2C	; 44
     20e:	f0 e0       	ldi	r31, 0x00	; 0
     210:	89 81       	ldd	r24, Y+1	; 0x01
     212:	80 83       	st	Z, r24

}
     214:	0f 90       	pop	r0
     216:	cf 91       	pop	r28
     218:	df 91       	pop	r29
     21a:	08 95       	ret

0000021c <UART_SendString>:

/**********************************************************************************/
void UART_SendString(u8_t* str){
     21c:	df 93       	push	r29
     21e:	cf 93       	push	r28
     220:	00 d0       	rcall	.+0      	; 0x222 <UART_SendString+0x6>
     222:	0f 92       	push	r0
     224:	cd b7       	in	r28, 0x3d	; 61
     226:	de b7       	in	r29, 0x3e	; 62
     228:	9b 83       	std	Y+3, r25	; 0x03
     22a:	8a 83       	std	Y+2, r24	; 0x02

	u8_t index =0;
     22c:	19 82       	std	Y+1, r1	; 0x01
     22e:	0e c0       	rjmp	.+28     	; 0x24c <UART_SendString+0x30>

	while(str[index] != '\0'){

		UART_SendByte(str[index]);
     230:	89 81       	ldd	r24, Y+1	; 0x01
     232:	28 2f       	mov	r18, r24
     234:	30 e0       	ldi	r19, 0x00	; 0
     236:	8a 81       	ldd	r24, Y+2	; 0x02
     238:	9b 81       	ldd	r25, Y+3	; 0x03
     23a:	fc 01       	movw	r30, r24
     23c:	e2 0f       	add	r30, r18
     23e:	f3 1f       	adc	r31, r19
     240:	80 81       	ld	r24, Z
     242:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <UART_SendByte>
		index++;
     246:	89 81       	ldd	r24, Y+1	; 0x01
     248:	8f 5f       	subi	r24, 0xFF	; 255
     24a:	89 83       	std	Y+1, r24	; 0x01
/**********************************************************************************/
void UART_SendString(u8_t* str){

	u8_t index =0;

	while(str[index] != '\0'){
     24c:	89 81       	ldd	r24, Y+1	; 0x01
     24e:	28 2f       	mov	r18, r24
     250:	30 e0       	ldi	r19, 0x00	; 0
     252:	8a 81       	ldd	r24, Y+2	; 0x02
     254:	9b 81       	ldd	r25, Y+3	; 0x03
     256:	fc 01       	movw	r30, r24
     258:	e2 0f       	add	r30, r18
     25a:	f3 1f       	adc	r31, r19
     25c:	80 81       	ld	r24, Z
     25e:	88 23       	and	r24, r24
     260:	39 f7       	brne	.-50     	; 0x230 <UART_SendString+0x14>

		UART_SendByte(str[index]);
		index++;
	}
}
     262:	0f 90       	pop	r0
     264:	0f 90       	pop	r0
     266:	0f 90       	pop	r0
     268:	cf 91       	pop	r28
     26a:	df 91       	pop	r29
     26c:	08 95       	ret

0000026e <UART_ReceiveString>:
/**********************************************************************************/
void UART_ReceiveString(u8_t* str){
     26e:	0f 93       	push	r16
     270:	1f 93       	push	r17
     272:	df 93       	push	r29
     274:	cf 93       	push	r28
     276:	00 d0       	rcall	.+0      	; 0x278 <UART_ReceiveString+0xa>
     278:	0f 92       	push	r0
     27a:	cd b7       	in	r28, 0x3d	; 61
     27c:	de b7       	in	r29, 0x3e	; 62
     27e:	9b 83       	std	Y+3, r25	; 0x03
     280:	8a 83       	std	Y+2, r24	; 0x02

	u8_t index =0;
     282:	19 82       	std	Y+1, r1	; 0x01

	str[index] =UART_ByteRecieved();
     284:	89 81       	ldd	r24, Y+1	; 0x01
     286:	28 2f       	mov	r18, r24
     288:	30 e0       	ldi	r19, 0x00	; 0
     28a:	8a 81       	ldd	r24, Y+2	; 0x02
     28c:	9b 81       	ldd	r25, Y+3	; 0x03
     28e:	8c 01       	movw	r16, r24
     290:	02 0f       	add	r16, r18
     292:	13 1f       	adc	r17, r19
     294:	0e 94 cc 00 	call	0x198	; 0x198 <UART_ByteRecieved>
     298:	f8 01       	movw	r30, r16
     29a:	80 83       	st	Z, r24
     29c:	0f c0       	rjmp	.+30     	; 0x2bc <UART_ReceiveString+0x4e>


	while(str[index] != '#')
	{
		index++;
     29e:	89 81       	ldd	r24, Y+1	; 0x01
     2a0:	8f 5f       	subi	r24, 0xFF	; 255
     2a2:	89 83       	std	Y+1, r24	; 0x01
		str[index] = UART_ByteRecieved();
     2a4:	89 81       	ldd	r24, Y+1	; 0x01
     2a6:	28 2f       	mov	r18, r24
     2a8:	30 e0       	ldi	r19, 0x00	; 0
     2aa:	8a 81       	ldd	r24, Y+2	; 0x02
     2ac:	9b 81       	ldd	r25, Y+3	; 0x03
     2ae:	8c 01       	movw	r16, r24
     2b0:	02 0f       	add	r16, r18
     2b2:	13 1f       	adc	r17, r19
     2b4:	0e 94 cc 00 	call	0x198	; 0x198 <UART_ByteRecieved>
     2b8:	f8 01       	movw	r30, r16
     2ba:	80 83       	st	Z, r24
	u8_t index =0;

	str[index] =UART_ByteRecieved();


	while(str[index] != '#')
     2bc:	89 81       	ldd	r24, Y+1	; 0x01
     2be:	28 2f       	mov	r18, r24
     2c0:	30 e0       	ldi	r19, 0x00	; 0
     2c2:	8a 81       	ldd	r24, Y+2	; 0x02
     2c4:	9b 81       	ldd	r25, Y+3	; 0x03
     2c6:	fc 01       	movw	r30, r24
     2c8:	e2 0f       	add	r30, r18
     2ca:	f3 1f       	adc	r31, r19
     2cc:	80 81       	ld	r24, Z
     2ce:	83 32       	cpi	r24, 0x23	; 35
     2d0:	31 f7       	brne	.-52     	; 0x29e <UART_ReceiveString+0x30>
		index++;
		str[index] = UART_ByteRecieved();
	}


	str[index]='\0';
     2d2:	89 81       	ldd	r24, Y+1	; 0x01
     2d4:	28 2f       	mov	r18, r24
     2d6:	30 e0       	ldi	r19, 0x00	; 0
     2d8:	8a 81       	ldd	r24, Y+2	; 0x02
     2da:	9b 81       	ldd	r25, Y+3	; 0x03
     2dc:	fc 01       	movw	r30, r24
     2de:	e2 0f       	add	r30, r18
     2e0:	f3 1f       	adc	r31, r19
     2e2:	10 82       	st	Z, r1

}
     2e4:	0f 90       	pop	r0
     2e6:	0f 90       	pop	r0
     2e8:	0f 90       	pop	r0
     2ea:	cf 91       	pop	r28
     2ec:	df 91       	pop	r29
     2ee:	1f 91       	pop	r17
     2f0:	0f 91       	pop	r16
     2f2:	08 95       	ret

000002f4 <KEYPAD_getPressedKey>:

/*******************************************************************************
 *                      Functions Definitions                                  *
 *******************************************************************************/
u8_t KEYPAD_getPressedKey(void)
{
     2f4:	df 93       	push	r29
     2f6:	cf 93       	push	r28
     2f8:	00 d0       	rcall	.+0      	; 0x2fa <KEYPAD_getPressedKey+0x6>
     2fa:	0f 92       	push	r0
     2fc:	cd b7       	in	r28, 0x3d	; 61
     2fe:	de b7       	in	r29, 0x3e	; 62
	u8_t col,row;
	u8_t keypad_port_value = 0;
     300:	19 82       	std	Y+1, r1	; 0x01
	while(1)
	{
		for(col=0;col<KEYPAD_NUM_COLS;col++) /* loop for columns */
     302:	1b 82       	std	Y+3, r1	; 0x03
     304:	42 c0       	rjmp	.+132    	; 0x38a <KEYPAD_getPressedKey+0x96>
		{
			/*
			 * Each time setup the direction for all keypad port as input pins,
			 * except this column will be output pin
			 */
			GPIO_setupPortDirection(KEYPAD_PORT_ID,PORT_INPUT);
     306:	80 e0       	ldi	r24, 0x00	; 0
     308:	60 e0       	ldi	r22, 0x00	; 0
     30a:	0e 94 f8 05 	call	0xbf0	; 0xbf0 <GPIO_setupPortDirection>
			mdio_setPinStatus(KEYPAD_PORT_ID, KEYPAD_FIRST_COLUMN_PIN_ID+col, DIO_OUTPUT_PIN);
     30e:	8b 81       	ldd	r24, Y+3	; 0x03
     310:	98 2f       	mov	r25, r24
     312:	9c 5f       	subi	r25, 0xFC	; 252
     314:	80 e0       	ldi	r24, 0x00	; 0
     316:	69 2f       	mov	r22, r25
     318:	40 e0       	ldi	r20, 0x00	; 0
     31a:	0e 94 1f 04 	call	0x83e	; 0x83e <mdio_setPinStatus>
//#if(KEYPAD_BUTTON_PRESSED == DIO_LOW_OUTPUT)
			/* Clear the column output pin and set the rest pins value */
			//keypad_port_value = ~(1<<(KEYPAD_FIRST_COLUMN_PIN_ID+col));
//#else
			/* Set the column output pin and clear the rest pins value */
			keypad_port_value = (1<<(KEYPAD_FIRST_COLUMN_PIN_ID+col));
     31e:	8b 81       	ldd	r24, Y+3	; 0x03
     320:	88 2f       	mov	r24, r24
     322:	90 e0       	ldi	r25, 0x00	; 0
     324:	9c 01       	movw	r18, r24
     326:	2c 5f       	subi	r18, 0xFC	; 252
     328:	3f 4f       	sbci	r19, 0xFF	; 255
     32a:	81 e0       	ldi	r24, 0x01	; 1
     32c:	90 e0       	ldi	r25, 0x00	; 0
     32e:	02 c0       	rjmp	.+4      	; 0x334 <KEYPAD_getPressedKey+0x40>
     330:	88 0f       	add	r24, r24
     332:	99 1f       	adc	r25, r25
     334:	2a 95       	dec	r18
     336:	e2 f7       	brpl	.-8      	; 0x330 <KEYPAD_getPressedKey+0x3c>
     338:	89 83       	std	Y+1, r24	; 0x01
//#endif
			GPIO_writePort(KEYPAD_PORT_ID,keypad_port_value);
     33a:	80 e0       	ldi	r24, 0x00	; 0
     33c:	69 81       	ldd	r22, Y+1	; 0x01
     33e:	0e 94 16 06 	call	0xc2c	; 0xc2c <GPIO_writePort>

			for(row=0;row<KEYPAD_NUM_ROWS;row++) /* loop for rows */
     342:	1a 82       	std	Y+2, r1	; 0x02
     344:	1c c0       	rjmp	.+56     	; 0x37e <KEYPAD_getPressedKey+0x8a>
			{
				/* Check if the switch is pressed in this row */
				if(mdio_getPinValue(KEYPAD_PORT_ID,row+KEYPAD_FIRST_ROW_PIN_ID) == KEYPAD_BUTTON_PRESSED)
     346:	80 e0       	ldi	r24, 0x00	; 0
     348:	6a 81       	ldd	r22, Y+2	; 0x02
     34a:	0e 94 c2 05 	call	0xb84	; 0xb84 <mdio_getPinValue>
     34e:	81 30       	cpi	r24, 0x01	; 1
     350:	99 f4       	brne	.+38     	; 0x378 <KEYPAD_getPressedKey+0x84>
				{
					#if (KEYPAD_NUM_COLS == 3)
						return KEYPAD_4x3_adjustKeyNumber((row*KEYPAD_NUM_COLS)+col+1);
					#elif (KEYPAD_NUM_COLS == 4)
						return KEYPAD_4x4_adjustKeyNumber((row*KEYPAD_NUM_COLS)+col+1);
     352:	8a 81       	ldd	r24, Y+2	; 0x02
     354:	88 2f       	mov	r24, r24
     356:	90 e0       	ldi	r25, 0x00	; 0
     358:	88 0f       	add	r24, r24
     35a:	99 1f       	adc	r25, r25
     35c:	88 0f       	add	r24, r24
     35e:	99 1f       	adc	r25, r25
     360:	98 2f       	mov	r25, r24
     362:	8b 81       	ldd	r24, Y+3	; 0x03
     364:	89 0f       	add	r24, r25
     366:	8f 5f       	subi	r24, 0xFF	; 255
     368:	0e 94 ca 01 	call	0x394	; 0x394 <KEYPAD_4x4_adjustKeyNumber>
					#endif
				}
			}
		}
	}
}
     36c:	0f 90       	pop	r0
     36e:	0f 90       	pop	r0
     370:	0f 90       	pop	r0
     372:	cf 91       	pop	r28
     374:	df 91       	pop	r29
     376:	08 95       	ret
			/* Set the column output pin and clear the rest pins value */
			keypad_port_value = (1<<(KEYPAD_FIRST_COLUMN_PIN_ID+col));
//#endif
			GPIO_writePort(KEYPAD_PORT_ID,keypad_port_value);

			for(row=0;row<KEYPAD_NUM_ROWS;row++) /* loop for rows */
     378:	8a 81       	ldd	r24, Y+2	; 0x02
     37a:	8f 5f       	subi	r24, 0xFF	; 255
     37c:	8a 83       	std	Y+2, r24	; 0x02
     37e:	8a 81       	ldd	r24, Y+2	; 0x02
     380:	84 30       	cpi	r24, 0x04	; 4
     382:	08 f3       	brcs	.-62     	; 0x346 <KEYPAD_getPressedKey+0x52>
{
	u8_t col,row;
	u8_t keypad_port_value = 0;
	while(1)
	{
		for(col=0;col<KEYPAD_NUM_COLS;col++) /* loop for columns */
     384:	8b 81       	ldd	r24, Y+3	; 0x03
     386:	8f 5f       	subi	r24, 0xFF	; 255
     388:	8b 83       	std	Y+3, r24	; 0x03
     38a:	8b 81       	ldd	r24, Y+3	; 0x03
     38c:	84 30       	cpi	r24, 0x04	; 4
     38e:	08 f4       	brcc	.+2      	; 0x392 <KEYPAD_getPressedKey+0x9e>
     390:	ba cf       	rjmp	.-140    	; 0x306 <KEYPAD_getPressedKey+0x12>
     392:	b7 cf       	rjmp	.-146    	; 0x302 <KEYPAD_getPressedKey+0xe>

00000394 <KEYPAD_4x4_adjustKeyNumber>:
/*
 * Description :
 * Update the keypad pressed button value with the correct one in keypad 4x4 shape
 */
static u8_t KEYPAD_4x4_adjustKeyNumber(u8_t button_number)
{
     394:	df 93       	push	r29
     396:	cf 93       	push	r28
     398:	00 d0       	rcall	.+0      	; 0x39a <KEYPAD_4x4_adjustKeyNumber+0x6>
     39a:	00 d0       	rcall	.+0      	; 0x39c <KEYPAD_4x4_adjustKeyNumber+0x8>
     39c:	cd b7       	in	r28, 0x3d	; 61
     39e:	de b7       	in	r29, 0x3e	; 62
     3a0:	8a 83       	std	Y+2, r24	; 0x02
	u8_t keypad_button = 0;
     3a2:	19 82       	std	Y+1, r1	; 0x01
	switch(button_number)
     3a4:	8a 81       	ldd	r24, Y+2	; 0x02
     3a6:	28 2f       	mov	r18, r24
     3a8:	30 e0       	ldi	r19, 0x00	; 0
     3aa:	3c 83       	std	Y+4, r19	; 0x04
     3ac:	2b 83       	std	Y+3, r18	; 0x03
     3ae:	8b 81       	ldd	r24, Y+3	; 0x03
     3b0:	9c 81       	ldd	r25, Y+4	; 0x04
     3b2:	88 30       	cpi	r24, 0x08	; 8
     3b4:	91 05       	cpc	r25, r1
     3b6:	09 f4       	brne	.+2      	; 0x3ba <KEYPAD_4x4_adjustKeyNumber+0x26>
     3b8:	70 c0       	rjmp	.+224    	; 0x49a <__stack+0x3b>
     3ba:	2b 81       	ldd	r18, Y+3	; 0x03
     3bc:	3c 81       	ldd	r19, Y+4	; 0x04
     3be:	29 30       	cpi	r18, 0x09	; 9
     3c0:	31 05       	cpc	r19, r1
     3c2:	5c f5       	brge	.+86     	; 0x41a <KEYPAD_4x4_adjustKeyNumber+0x86>
     3c4:	8b 81       	ldd	r24, Y+3	; 0x03
     3c6:	9c 81       	ldd	r25, Y+4	; 0x04
     3c8:	84 30       	cpi	r24, 0x04	; 4
     3ca:	91 05       	cpc	r25, r1
     3cc:	09 f4       	brne	.+2      	; 0x3d0 <KEYPAD_4x4_adjustKeyNumber+0x3c>
     3ce:	59 c0       	rjmp	.+178    	; 0x482 <__stack+0x23>
     3d0:	2b 81       	ldd	r18, Y+3	; 0x03
     3d2:	3c 81       	ldd	r19, Y+4	; 0x04
     3d4:	25 30       	cpi	r18, 0x05	; 5
     3d6:	31 05       	cpc	r19, r1
     3d8:	9c f4       	brge	.+38     	; 0x400 <KEYPAD_4x4_adjustKeyNumber+0x6c>
     3da:	8b 81       	ldd	r24, Y+3	; 0x03
     3dc:	9c 81       	ldd	r25, Y+4	; 0x04
     3de:	82 30       	cpi	r24, 0x02	; 2
     3e0:	91 05       	cpc	r25, r1
     3e2:	09 f4       	brne	.+2      	; 0x3e6 <KEYPAD_4x4_adjustKeyNumber+0x52>
     3e4:	48 c0       	rjmp	.+144    	; 0x476 <__stack+0x17>
     3e6:	2b 81       	ldd	r18, Y+3	; 0x03
     3e8:	3c 81       	ldd	r19, Y+4	; 0x04
     3ea:	23 30       	cpi	r18, 0x03	; 3
     3ec:	31 05       	cpc	r19, r1
     3ee:	0c f0       	brlt	.+2      	; 0x3f2 <KEYPAD_4x4_adjustKeyNumber+0x5e>
     3f0:	45 c0       	rjmp	.+138    	; 0x47c <__stack+0x1d>
     3f2:	8b 81       	ldd	r24, Y+3	; 0x03
     3f4:	9c 81       	ldd	r25, Y+4	; 0x04
     3f6:	81 30       	cpi	r24, 0x01	; 1
     3f8:	91 05       	cpc	r25, r1
     3fa:	09 f4       	brne	.+2      	; 0x3fe <KEYPAD_4x4_adjustKeyNumber+0x6a>
     3fc:	39 c0       	rjmp	.+114    	; 0x470 <__stack+0x11>
     3fe:	67 c0       	rjmp	.+206    	; 0x4ce <__stack+0x6f>
     400:	2b 81       	ldd	r18, Y+3	; 0x03
     402:	3c 81       	ldd	r19, Y+4	; 0x04
     404:	26 30       	cpi	r18, 0x06	; 6
     406:	31 05       	cpc	r19, r1
     408:	09 f4       	brne	.+2      	; 0x40c <KEYPAD_4x4_adjustKeyNumber+0x78>
     40a:	41 c0       	rjmp	.+130    	; 0x48e <__stack+0x2f>
     40c:	8b 81       	ldd	r24, Y+3	; 0x03
     40e:	9c 81       	ldd	r25, Y+4	; 0x04
     410:	87 30       	cpi	r24, 0x07	; 7
     412:	91 05       	cpc	r25, r1
     414:	0c f0       	brlt	.+2      	; 0x418 <KEYPAD_4x4_adjustKeyNumber+0x84>
     416:	3e c0       	rjmp	.+124    	; 0x494 <__stack+0x35>
     418:	37 c0       	rjmp	.+110    	; 0x488 <__stack+0x29>
     41a:	2b 81       	ldd	r18, Y+3	; 0x03
     41c:	3c 81       	ldd	r19, Y+4	; 0x04
     41e:	2c 30       	cpi	r18, 0x0C	; 12
     420:	31 05       	cpc	r19, r1
     422:	09 f4       	brne	.+2      	; 0x426 <KEYPAD_4x4_adjustKeyNumber+0x92>
     424:	46 c0       	rjmp	.+140    	; 0x4b2 <__stack+0x53>
     426:	8b 81       	ldd	r24, Y+3	; 0x03
     428:	9c 81       	ldd	r25, Y+4	; 0x04
     42a:	8d 30       	cpi	r24, 0x0D	; 13
     42c:	91 05       	cpc	r25, r1
     42e:	5c f4       	brge	.+22     	; 0x446 <KEYPAD_4x4_adjustKeyNumber+0xb2>
     430:	2b 81       	ldd	r18, Y+3	; 0x03
     432:	3c 81       	ldd	r19, Y+4	; 0x04
     434:	2a 30       	cpi	r18, 0x0A	; 10
     436:	31 05       	cpc	r19, r1
     438:	b1 f1       	breq	.+108    	; 0x4a6 <__stack+0x47>
     43a:	8b 81       	ldd	r24, Y+3	; 0x03
     43c:	9c 81       	ldd	r25, Y+4	; 0x04
     43e:	8b 30       	cpi	r24, 0x0B	; 11
     440:	91 05       	cpc	r25, r1
     442:	a4 f5       	brge	.+104    	; 0x4ac <__stack+0x4d>
     444:	2d c0       	rjmp	.+90     	; 0x4a0 <__stack+0x41>
     446:	2b 81       	ldd	r18, Y+3	; 0x03
     448:	3c 81       	ldd	r19, Y+4	; 0x04
     44a:	2e 30       	cpi	r18, 0x0E	; 14
     44c:	31 05       	cpc	r19, r1
     44e:	b9 f1       	breq	.+110    	; 0x4be <__stack+0x5f>
     450:	8b 81       	ldd	r24, Y+3	; 0x03
     452:	9c 81       	ldd	r25, Y+4	; 0x04
     454:	8e 30       	cpi	r24, 0x0E	; 14
     456:	91 05       	cpc	r25, r1
     458:	7c f1       	brlt	.+94     	; 0x4b8 <__stack+0x59>
     45a:	2b 81       	ldd	r18, Y+3	; 0x03
     45c:	3c 81       	ldd	r19, Y+4	; 0x04
     45e:	2f 30       	cpi	r18, 0x0F	; 15
     460:	31 05       	cpc	r19, r1
     462:	79 f1       	breq	.+94     	; 0x4c2 <__stack+0x63>
     464:	8b 81       	ldd	r24, Y+3	; 0x03
     466:	9c 81       	ldd	r25, Y+4	; 0x04
     468:	80 31       	cpi	r24, 0x10	; 16
     46a:	91 05       	cpc	r25, r1
     46c:	69 f1       	breq	.+90     	; 0x4c8 <__stack+0x69>
     46e:	2f c0       	rjmp	.+94     	; 0x4ce <__stack+0x6f>
	{
		case 1: keypad_button = 7;
     470:	87 e0       	ldi	r24, 0x07	; 7
     472:	89 83       	std	Y+1, r24	; 0x01
     474:	2e c0       	rjmp	.+92     	; 0x4d2 <__stack+0x73>
				break;
		case 2: keypad_button = 8;
     476:	88 e0       	ldi	r24, 0x08	; 8
     478:	89 83       	std	Y+1, r24	; 0x01
     47a:	2b c0       	rjmp	.+86     	; 0x4d2 <__stack+0x73>
				break;
		case 3: keypad_button = 9;
     47c:	89 e0       	ldi	r24, 0x09	; 9
     47e:	89 83       	std	Y+1, r24	; 0x01
     480:	28 c0       	rjmp	.+80     	; 0x4d2 <__stack+0x73>
				break;
		case 4: keypad_button = '%'; // ASCII Code of %
     482:	85 e2       	ldi	r24, 0x25	; 37
     484:	89 83       	std	Y+1, r24	; 0x01
     486:	25 c0       	rjmp	.+74     	; 0x4d2 <__stack+0x73>
				break;
		case 5: keypad_button = 4;
     488:	84 e0       	ldi	r24, 0x04	; 4
     48a:	89 83       	std	Y+1, r24	; 0x01
     48c:	22 c0       	rjmp	.+68     	; 0x4d2 <__stack+0x73>
				break;
		case 6: keypad_button = 5;
     48e:	85 e0       	ldi	r24, 0x05	; 5
     490:	89 83       	std	Y+1, r24	; 0x01
     492:	1f c0       	rjmp	.+62     	; 0x4d2 <__stack+0x73>
				break;
		case 7: keypad_button = 6;
     494:	86 e0       	ldi	r24, 0x06	; 6
     496:	89 83       	std	Y+1, r24	; 0x01
     498:	1c c0       	rjmp	.+56     	; 0x4d2 <__stack+0x73>
				break;
		case 8: keypad_button = '*'; /* ASCII Code of '*' */
     49a:	8a e2       	ldi	r24, 0x2A	; 42
     49c:	89 83       	std	Y+1, r24	; 0x01
     49e:	19 c0       	rjmp	.+50     	; 0x4d2 <__stack+0x73>
				break;
		case 9: keypad_button = 1;
     4a0:	81 e0       	ldi	r24, 0x01	; 1
     4a2:	89 83       	std	Y+1, r24	; 0x01
     4a4:	16 c0       	rjmp	.+44     	; 0x4d2 <__stack+0x73>
				break;
		case 10: keypad_button = 2;
     4a6:	82 e0       	ldi	r24, 0x02	; 2
     4a8:	89 83       	std	Y+1, r24	; 0x01
     4aa:	13 c0       	rjmp	.+38     	; 0x4d2 <__stack+0x73>
				break;
		case 11: keypad_button = 3;
     4ac:	83 e0       	ldi	r24, 0x03	; 3
     4ae:	89 83       	std	Y+1, r24	; 0x01
     4b0:	10 c0       	rjmp	.+32     	; 0x4d2 <__stack+0x73>
				break;
		case 12: keypad_button = '-'; /* ASCII Code of '-' */
     4b2:	8d e2       	ldi	r24, 0x2D	; 45
     4b4:	89 83       	std	Y+1, r24	; 0x01
     4b6:	0d c0       	rjmp	.+26     	; 0x4d2 <__stack+0x73>
				break;
		case 13: keypad_button = 13;  /* ASCII of Enter */
     4b8:	8d e0       	ldi	r24, 0x0D	; 13
     4ba:	89 83       	std	Y+1, r24	; 0x01
     4bc:	0a c0       	rjmp	.+20     	; 0x4d2 <__stack+0x73>
				break;
		case 14: keypad_button = 0;
     4be:	19 82       	std	Y+1, r1	; 0x01
     4c0:	08 c0       	rjmp	.+16     	; 0x4d2 <__stack+0x73>
				break;
		case 15: keypad_button = '='; /* ASCII Code of '=' */
     4c2:	8d e3       	ldi	r24, 0x3D	; 61
     4c4:	89 83       	std	Y+1, r24	; 0x01
     4c6:	05 c0       	rjmp	.+10     	; 0x4d2 <__stack+0x73>
				break;
		case 16: keypad_button = '+'; /* ASCII Code of '+' */
     4c8:	8b e2       	ldi	r24, 0x2B	; 43
     4ca:	89 83       	std	Y+1, r24	; 0x01
     4cc:	02 c0       	rjmp	.+4      	; 0x4d2 <__stack+0x73>
				break;
		default: keypad_button = button_number;
     4ce:	8a 81       	ldd	r24, Y+2	; 0x02
     4d0:	89 83       	std	Y+1, r24	; 0x01
				break;
	}
	return keypad_button;
     4d2:	89 81       	ldd	r24, Y+1	; 0x01
}
     4d4:	0f 90       	pop	r0
     4d6:	0f 90       	pop	r0
     4d8:	0f 90       	pop	r0
     4da:	0f 90       	pop	r0
     4dc:	cf 91       	pop	r28
     4de:	df 91       	pop	r29
     4e0:	08 95       	ret

000004e2 <LCD_init>:
 * 2. Setup the LCD Data Mode 4-bits or 8-bits.
 */


void LCD_init(void)
{
     4e2:	df 93       	push	r29
     4e4:	cf 93       	push	r28
     4e6:	cd b7       	in	r28, 0x3d	; 61
     4e8:	de b7       	in	r29, 0x3e	; 62
	DelayTimer_8bits_Init ( &delayTimer0_milli , TIMER0_INDEX_ARRAY);
     4ea:	87 e0       	ldi	r24, 0x07	; 7
     4ec:	91 e0       	ldi	r25, 0x01	; 1
     4ee:	60 e0       	ldi	r22, 0x00	; 0
     4f0:	0e 94 9e 0a 	call	0x153c	; 0x153c <DelayTimer_8bits_Init>

	/* Configure the direction for RS, RW and E pins as output pins */
	mdio_setPinStatus(LCD_RS_PORT_ID,LCD_RS_PIN_ID,DIO_OUTPUT_PIN);
     4f4:	83 e0       	ldi	r24, 0x03	; 3
     4f6:	64 e0       	ldi	r22, 0x04	; 4
     4f8:	40 e0       	ldi	r20, 0x00	; 0
     4fa:	0e 94 1f 04 	call	0x83e	; 0x83e <mdio_setPinStatus>
	mdio_setPinStatus(LCD_RW_PORT_ID,LCD_RW_PIN_ID,DIO_OUTPUT_PIN);
     4fe:	83 e0       	ldi	r24, 0x03	; 3
     500:	65 e0       	ldi	r22, 0x05	; 5
     502:	40 e0       	ldi	r20, 0x00	; 0
     504:	0e 94 1f 04 	call	0x83e	; 0x83e <mdio_setPinStatus>
	mdio_setPinStatus(LCD_E_PORT_ID,LCD_E_PIN_ID,DIO_OUTPUT_PIN);
     508:	83 e0       	ldi	r24, 0x03	; 3
     50a:	66 e0       	ldi	r22, 0x06	; 6
     50c:	40 e0       	ldi	r20, 0x00	; 0
     50e:	0e 94 1f 04 	call	0x83e	; 0x83e <mdio_setPinStatus>
	LCD_sendCommand(LCD_GO_TO_HOME);
	LCD_sendCommand(LCD_TWO_LINES_FOUR_BITS_MODE); /* use 2-line lcd + 4-bit Data Mode + 5*7 dot display Mode */

#elif (LCD_DATA_BITS_MODE == 8)
	/* Configure the data port as output port */
	 GPIO_setupPortDirection(LCD_DATA_PORT_ID,PORT_OUTPUT);
     512:	82 e0       	ldi	r24, 0x02	; 2
     514:	6f ef       	ldi	r22, 0xFF	; 255
     516:	0e 94 f8 05 	call	0xbf0	; 0xbf0 <GPIO_setupPortDirection>
	 LCD_sendCommand(LCD_TWO_LINES_EIGHT_BITS_MODE); /* use 2-line lcd + 8-bit Data Mode + 5*7 dot display Mode */
     51a:	88 e3       	ldi	r24, 0x38	; 56
     51c:	0e 94 99 02 	call	0x532	; 0x532 <LCD_sendCommand>
#endif

	LCD_sendCommand(LCD_CURSOR_OFF); /* cursor off */
     520:	8c e0       	ldi	r24, 0x0C	; 12
     522:	0e 94 99 02 	call	0x532	; 0x532 <LCD_sendCommand>
	LCD_sendCommand(LCD_CLEAR_COMMAND); /* clear LCD at the beginning */
     526:	81 e0       	ldi	r24, 0x01	; 1
     528:	0e 94 99 02 	call	0x532	; 0x532 <LCD_sendCommand>
}
     52c:	cf 91       	pop	r28
     52e:	df 91       	pop	r29
     530:	08 95       	ret

00000532 <LCD_sendCommand>:
/*
 * Description :
 * Send the required command to the screen
 */
void LCD_sendCommand(u8_t command)
{
     532:	df 93       	push	r29
     534:	cf 93       	push	r28
     536:	0f 92       	push	r0
     538:	cd b7       	in	r28, 0x3d	; 61
     53a:	de b7       	in	r29, 0x3e	; 62
     53c:	89 83       	std	Y+1, r24	; 0x01
	//u8_t lcd_port_value = 0;
	mdio_setPinValue(LCD_RS_PORT_ID,LCD_RS_PIN_ID,DIO_LOW_OUTPUT); /* Instruction Mode RS=0 */
     53e:	83 e0       	ldi	r24, 0x03	; 3
     540:	64 e0       	ldi	r22, 0x04	; 4
     542:	40 e0       	ldi	r20, 0x00	; 0
     544:	0e 94 03 05 	call	0xa06	; 0xa06 <mdio_setPinValue>
	mdio_setPinValue(LCD_RW_PORT_ID,LCD_RW_PIN_ID,DIO_LOW_OUTPUT); /* write data to LCD so RW=0 */
     548:	83 e0       	ldi	r24, 0x03	; 3
     54a:	65 e0       	ldi	r22, 0x05	; 5
     54c:	40 e0       	ldi	r20, 0x00	; 0
     54e:	0e 94 03 05 	call	0xa06	; 0xa06 <mdio_setPinValue>
	What really matters is that all these signals must be stable for a minimum or a maximum period of time.
	For example lines RS and R/W must be stable for a minimum period of time
	before level logic on the 'E' line is raised to a logic 1.*/


	DelayTimer_8bits_synchrounous( _1_milli_sec, TIMER0_INDEX_ARRAY);
     552:	81 e0       	ldi	r24, 0x01	; 1
     554:	90 e0       	ldi	r25, 0x00	; 0
     556:	60 e0       	ldi	r22, 0x00	; 0
     558:	0e 94 0d 0b 	call	0x161a	; 0x161a <DelayTimer_8bits_synchrounous>


	mdio_setPinValue(LCD_E_PORT_ID,LCD_E_PIN_ID,DIO_HIGH_OUTPUT); /* Enable LCD E=1 */
     55c:	83 e0       	ldi	r24, 0x03	; 3
     55e:	66 e0       	ldi	r22, 0x06	; 6
     560:	41 e0       	ldi	r20, 0x01	; 1
     562:	0e 94 03 05 	call	0xa06	; 0xa06 <mdio_setPinValue>
		 * minimum time of 190ns to stabilize the signal to
		 *ensure that Enable signal is high before reading the data signal
		 *NOTE ---> the enable pin must be high in order to read and send the data signal to the buffer
		 *The equation for calculating that time Tpw - Tdws */

	DelayTimer_8bits_synchrounous( _1_milli_sec, TIMER0_INDEX_ARRAY);
     566:	81 e0       	ldi	r24, 0x01	; 1
     568:	90 e0       	ldi	r25, 0x00	; 0
     56a:	60 e0       	ldi	r22, 0x00	; 0
     56c:	0e 94 0d 0b 	call	0x161a	; 0x161a <DelayTimer_8bits_synchrounous>
	mtimer_delayMs_sync(MTIMER_CHANNEL_1, 1); /* delay for processing Tdsw = 100ns */
	mdio_setPinValue(LCD_E_PORT_ID,LCD_E_PIN_ID,DIO_LOW_OUTPUT); /* Disable LCD E=0 */
	mtimer_delayMs_sync(MTIMER_CHANNEL_1, 1); /* delay for processing Th = 13ns */

#elif (LCD_DATA_BITS_MODE == 8)
	GPIO_writePort(LCD_DATA_PORT_ID,command); /* out the required command to the data bus D0 --> D7 */
     570:	82 e0       	ldi	r24, 0x02	; 2
     572:	69 81       	ldd	r22, Y+1	; 0x01
     574:	0e 94 16 06 	call	0xc2c	; 0xc2c <GPIO_writePort>
	 /* delay for processing Tdsw = 100ns */
	DelayTimer_8bits_synchrounous( _1_milli_sec,TIMER0_INDEX_ARRAY);
     578:	81 e0       	ldi	r24, 0x01	; 1
     57a:	90 e0       	ldi	r25, 0x00	; 0
     57c:	60 e0       	ldi	r22, 0x00	; 0
     57e:	0e 94 0d 0b 	call	0x161a	; 0x161a <DelayTimer_8bits_synchrounous>

	mdio_setPinValue(LCD_E_PORT_ID,LCD_E_PIN_ID,DIO_LOW_OUTPUT); /* Disable LCD E=0 */
     582:	83 e0       	ldi	r24, 0x03	; 3
     584:	66 e0       	ldi	r22, 0x06	; 6
     586:	40 e0       	ldi	r20, 0x00	; 0
     588:	0e 94 03 05 	call	0xa06	; 0xa06 <mdio_setPinValue>
	 /* delay for processing Th = 13ns */
	DelayTimer_8bits_synchrounous( _1_milli_sec,TIMER0_INDEX_ARRAY );
     58c:	81 e0       	ldi	r24, 0x01	; 1
     58e:	90 e0       	ldi	r25, 0x00	; 0
     590:	60 e0       	ldi	r22, 0x00	; 0
     592:	0e 94 0d 0b 	call	0x161a	; 0x161a <DelayTimer_8bits_synchrounous>
#endif
}
     596:	0f 90       	pop	r0
     598:	cf 91       	pop	r28
     59a:	df 91       	pop	r29
     59c:	08 95       	ret

0000059e <LCD_displayCharacter>:
/*
 * Description :
 * Display the required character on the screen
 */
void LCD_displayCharacter(u8_t data)
{
     59e:	df 93       	push	r29
     5a0:	cf 93       	push	r28
     5a2:	0f 92       	push	r0
     5a4:	cd b7       	in	r28, 0x3d	; 61
     5a6:	de b7       	in	r29, 0x3e	; 62
     5a8:	89 83       	std	Y+1, r24	; 0x01
	//u8_t lcd_port_value = 0;
	mdio_setPinValue(LCD_RS_PORT_ID,LCD_RS_PIN_ID,DIO_HIGH_OUTPUT); /* Data Mode RS=1 */
     5aa:	83 e0       	ldi	r24, 0x03	; 3
     5ac:	64 e0       	ldi	r22, 0x04	; 4
     5ae:	41 e0       	ldi	r20, 0x01	; 1
     5b0:	0e 94 03 05 	call	0xa06	; 0xa06 <mdio_setPinValue>
	mdio_setPinValue(LCD_RW_PORT_ID,LCD_RW_PIN_ID,DIO_LOW_OUTPUT); /* write data to LCD so RW=0 */
     5b4:	83 e0       	ldi	r24, 0x03	; 3
     5b6:	65 e0       	ldi	r22, 0x05	; 5
     5b8:	40 e0       	ldi	r20, 0x00	; 0
     5ba:	0e 94 03 05 	call	0xa06	; 0xa06 <mdio_setPinValue>

	 /* delay for processing Tas = 50ns */
	 DelayTimer_8bits_synchrounous( _1_milli_sec,TIMER0_INDEX_ARRAY);
     5be:	81 e0       	ldi	r24, 0x01	; 1
     5c0:	90 e0       	ldi	r25, 0x00	; 0
     5c2:	60 e0       	ldi	r22, 0x00	; 0
     5c4:	0e 94 0d 0b 	call	0x161a	; 0x161a <DelayTimer_8bits_synchrounous>

	mdio_setPinValue(LCD_E_PORT_ID,LCD_E_PIN_ID,DIO_HIGH_OUTPUT); /* Enable LCD E=1 */
     5c8:	83 e0       	ldi	r24, 0x03	; 3
     5ca:	66 e0       	ldi	r22, 0x06	; 6
     5cc:	41 e0       	ldi	r20, 0x01	; 1
     5ce:	0e 94 03 05 	call	0xa06	; 0xa06 <mdio_setPinValue>
	/* delay for processing Tpw - Tdws = 190ns */
	 DelayTimer_8bits_synchrounous( _1_milli_sec,TIMER0_INDEX_ARRAY);
     5d2:	81 e0       	ldi	r24, 0x01	; 1
     5d4:	90 e0       	ldi	r25, 0x00	; 0
     5d6:	60 e0       	ldi	r22, 0x00	; 0
     5d8:	0e 94 0d 0b 	call	0x161a	; 0x161a <DelayTimer_8bits_synchrounous>
	mtimer_delayMs_sync(MTIMER_CHANNEL_1, 1); /* delay for processing Tdsw = 100ns */
	mdio_setPinValue(LCD_E_PORT_ID,LCD_E_PIN_ID,DIO_LOW_OUTPUT); /* Disable LCD E=0 */
	mtimer_delayMs_sync(MTIMER_CHANNEL_1, 1); /* delay for processing Th = 13ns */

#elif (LCD_DATA_BITS_MODE == 8)
	 GPIO_writePort(LCD_DATA_PORT_ID,data); /* out the required data to the data bus D0 --> D7 */
     5dc:	82 e0       	ldi	r24, 0x02	; 2
     5de:	69 81       	ldd	r22, Y+1	; 0x01
     5e0:	0e 94 16 06 	call	0xc2c	; 0xc2c <GPIO_writePort>

	/* delay for processing Tdsw = 100ns */
	 DelayTimer_8bits_synchrounous( _1_milli_sec,TIMER0_INDEX_ARRAY);
     5e4:	81 e0       	ldi	r24, 0x01	; 1
     5e6:	90 e0       	ldi	r25, 0x00	; 0
     5e8:	60 e0       	ldi	r22, 0x00	; 0
     5ea:	0e 94 0d 0b 	call	0x161a	; 0x161a <DelayTimer_8bits_synchrounous>

	mdio_setPinValue(LCD_E_PORT_ID,LCD_E_PIN_ID,DIO_LOW_OUTPUT); /* Disable LCD E=0 */
     5ee:	83 e0       	ldi	r24, 0x03	; 3
     5f0:	66 e0       	ldi	r22, 0x06	; 6
     5f2:	40 e0       	ldi	r20, 0x00	; 0
     5f4:	0e 94 03 05 	call	0xa06	; 0xa06 <mdio_setPinValue>
	/* delay for processing Th = 13ns */
	 DelayTimer_8bits_synchrounous( _1_milli_sec,TIMER0_INDEX_ARRAY);
     5f8:	81 e0       	ldi	r24, 0x01	; 1
     5fa:	90 e0       	ldi	r25, 0x00	; 0
     5fc:	60 e0       	ldi	r22, 0x00	; 0
     5fe:	0e 94 0d 0b 	call	0x161a	; 0x161a <DelayTimer_8bits_synchrounous>
#endif
}
     602:	0f 90       	pop	r0
     604:	cf 91       	pop	r28
     606:	df 91       	pop	r29
     608:	08 95       	ret

0000060a <LCD_displayString>:
/*
 * Description :
 * Display the required string on the screen
 */
void LCD_displayString(const char *Str)
{
     60a:	df 93       	push	r29
     60c:	cf 93       	push	r28
     60e:	00 d0       	rcall	.+0      	; 0x610 <LCD_displayString+0x6>
     610:	0f 92       	push	r0
     612:	cd b7       	in	r28, 0x3d	; 61
     614:	de b7       	in	r29, 0x3e	; 62
     616:	9b 83       	std	Y+3, r25	; 0x03
     618:	8a 83       	std	Y+2, r24	; 0x02
	u8_t i = 0;
     61a:	19 82       	std	Y+1, r1	; 0x01
     61c:	0e c0       	rjmp	.+28     	; 0x63a <LCD_displayString+0x30>
	while(Str[i] != '\0')
	{
		LCD_displayCharacter(Str[i]);
     61e:	89 81       	ldd	r24, Y+1	; 0x01
     620:	28 2f       	mov	r18, r24
     622:	30 e0       	ldi	r19, 0x00	; 0
     624:	8a 81       	ldd	r24, Y+2	; 0x02
     626:	9b 81       	ldd	r25, Y+3	; 0x03
     628:	fc 01       	movw	r30, r24
     62a:	e2 0f       	add	r30, r18
     62c:	f3 1f       	adc	r31, r19
     62e:	80 81       	ld	r24, Z
     630:	0e 94 cf 02 	call	0x59e	; 0x59e <LCD_displayCharacter>
		i++;
     634:	89 81       	ldd	r24, Y+1	; 0x01
     636:	8f 5f       	subi	r24, 0xFF	; 255
     638:	89 83       	std	Y+1, r24	; 0x01
 * Display the required string on the screen
 */
void LCD_displayString(const char *Str)
{
	u8_t i = 0;
	while(Str[i] != '\0')
     63a:	89 81       	ldd	r24, Y+1	; 0x01
     63c:	28 2f       	mov	r18, r24
     63e:	30 e0       	ldi	r19, 0x00	; 0
     640:	8a 81       	ldd	r24, Y+2	; 0x02
     642:	9b 81       	ldd	r25, Y+3	; 0x03
     644:	fc 01       	movw	r30, r24
     646:	e2 0f       	add	r30, r18
     648:	f3 1f       	adc	r31, r19
     64a:	80 81       	ld	r24, Z
     64c:	88 23       	and	r24, r24
     64e:	39 f7       	brne	.-50     	; 0x61e <LCD_displayString+0x14>
	{
		LCD_displayCharacter(*Str);
		Str++;
	}
	*********************************************************/
}
     650:	0f 90       	pop	r0
     652:	0f 90       	pop	r0
     654:	0f 90       	pop	r0
     656:	cf 91       	pop	r28
     658:	df 91       	pop	r29
     65a:	08 95       	ret

0000065c <LCD_moveCursor>:
/*
 * Description :
 * Move the cursor to a specified row and column index on the screen
 */
void LCD_moveCursor(u8_t row,u8_t col)
{
     65c:	df 93       	push	r29
     65e:	cf 93       	push	r28
     660:	00 d0       	rcall	.+0      	; 0x662 <LCD_moveCursor+0x6>
     662:	00 d0       	rcall	.+0      	; 0x664 <LCD_moveCursor+0x8>
     664:	0f 92       	push	r0
     666:	cd b7       	in	r28, 0x3d	; 61
     668:	de b7       	in	r29, 0x3e	; 62
     66a:	8a 83       	std	Y+2, r24	; 0x02
     66c:	6b 83       	std	Y+3, r22	; 0x03
	u8_t lcd_memory_address;

	/* Calculate the required address in the LCD DDRAM */
	switch(row)
     66e:	8a 81       	ldd	r24, Y+2	; 0x02
     670:	28 2f       	mov	r18, r24
     672:	30 e0       	ldi	r19, 0x00	; 0
     674:	3d 83       	std	Y+5, r19	; 0x05
     676:	2c 83       	std	Y+4, r18	; 0x04
     678:	8c 81       	ldd	r24, Y+4	; 0x04
     67a:	9d 81       	ldd	r25, Y+5	; 0x05
     67c:	81 30       	cpi	r24, 0x01	; 1
     67e:	91 05       	cpc	r25, r1
     680:	c1 f0       	breq	.+48     	; 0x6b2 <LCD_moveCursor+0x56>
     682:	2c 81       	ldd	r18, Y+4	; 0x04
     684:	3d 81       	ldd	r19, Y+5	; 0x05
     686:	22 30       	cpi	r18, 0x02	; 2
     688:	31 05       	cpc	r19, r1
     68a:	2c f4       	brge	.+10     	; 0x696 <LCD_moveCursor+0x3a>
     68c:	8c 81       	ldd	r24, Y+4	; 0x04
     68e:	9d 81       	ldd	r25, Y+5	; 0x05
     690:	00 97       	sbiw	r24, 0x00	; 0
     692:	61 f0       	breq	.+24     	; 0x6ac <LCD_moveCursor+0x50>
     694:	19 c0       	rjmp	.+50     	; 0x6c8 <LCD_moveCursor+0x6c>
     696:	2c 81       	ldd	r18, Y+4	; 0x04
     698:	3d 81       	ldd	r19, Y+5	; 0x05
     69a:	22 30       	cpi	r18, 0x02	; 2
     69c:	31 05       	cpc	r19, r1
     69e:	69 f0       	breq	.+26     	; 0x6ba <LCD_moveCursor+0x5e>
     6a0:	8c 81       	ldd	r24, Y+4	; 0x04
     6a2:	9d 81       	ldd	r25, Y+5	; 0x05
     6a4:	83 30       	cpi	r24, 0x03	; 3
     6a6:	91 05       	cpc	r25, r1
     6a8:	61 f0       	breq	.+24     	; 0x6c2 <LCD_moveCursor+0x66>
     6aa:	0e c0       	rjmp	.+28     	; 0x6c8 <LCD_moveCursor+0x6c>
	{
		case 0:
			lcd_memory_address=col;
     6ac:	8b 81       	ldd	r24, Y+3	; 0x03
     6ae:	89 83       	std	Y+1, r24	; 0x01
     6b0:	0b c0       	rjmp	.+22     	; 0x6c8 <LCD_moveCursor+0x6c>
				break;
		case 1:
			lcd_memory_address=col+0x40;
     6b2:	8b 81       	ldd	r24, Y+3	; 0x03
     6b4:	80 5c       	subi	r24, 0xC0	; 192
     6b6:	89 83       	std	Y+1, r24	; 0x01
     6b8:	07 c0       	rjmp	.+14     	; 0x6c8 <LCD_moveCursor+0x6c>
				break;
		case 2:
			lcd_memory_address=col+0x10;
     6ba:	8b 81       	ldd	r24, Y+3	; 0x03
     6bc:	80 5f       	subi	r24, 0xF0	; 240
     6be:	89 83       	std	Y+1, r24	; 0x01
     6c0:	03 c0       	rjmp	.+6      	; 0x6c8 <LCD_moveCursor+0x6c>
				break;
		case 3:
			lcd_memory_address=col+0x50;
     6c2:	8b 81       	ldd	r24, Y+3	; 0x03
     6c4:	80 5b       	subi	r24, 0xB0	; 176
     6c6:	89 83       	std	Y+1, r24	; 0x01
				break;
	}
	/* Move the LCD cursor to this specific address */
	LCD_sendCommand(lcd_memory_address | LCD_SET_CURSOR_LOCATION);
     6c8:	89 81       	ldd	r24, Y+1	; 0x01
     6ca:	80 68       	ori	r24, 0x80	; 128
     6cc:	0e 94 99 02 	call	0x532	; 0x532 <LCD_sendCommand>
}
     6d0:	0f 90       	pop	r0
     6d2:	0f 90       	pop	r0
     6d4:	0f 90       	pop	r0
     6d6:	0f 90       	pop	r0
     6d8:	0f 90       	pop	r0
     6da:	cf 91       	pop	r28
     6dc:	df 91       	pop	r29
     6de:	08 95       	ret

000006e0 <LCD_displayStringRowColumn>:
/*
 * Description :
 * Display the required string in a specified row and column index on the screen
 */
void LCD_displayStringRowColumn(u8_t row,u8_t col,const char *Str)
{
     6e0:	df 93       	push	r29
     6e2:	cf 93       	push	r28
     6e4:	00 d0       	rcall	.+0      	; 0x6e6 <LCD_displayStringRowColumn+0x6>
     6e6:	00 d0       	rcall	.+0      	; 0x6e8 <LCD_displayStringRowColumn+0x8>
     6e8:	cd b7       	in	r28, 0x3d	; 61
     6ea:	de b7       	in	r29, 0x3e	; 62
     6ec:	89 83       	std	Y+1, r24	; 0x01
     6ee:	6a 83       	std	Y+2, r22	; 0x02
     6f0:	5c 83       	std	Y+4, r21	; 0x04
     6f2:	4b 83       	std	Y+3, r20	; 0x03
	LCD_moveCursor(row,col); /* go to to the required LCD position */
     6f4:	89 81       	ldd	r24, Y+1	; 0x01
     6f6:	6a 81       	ldd	r22, Y+2	; 0x02
     6f8:	0e 94 2e 03 	call	0x65c	; 0x65c <LCD_moveCursor>
	LCD_displayString(Str); /* display the string */
     6fc:	8b 81       	ldd	r24, Y+3	; 0x03
     6fe:	9c 81       	ldd	r25, Y+4	; 0x04
     700:	0e 94 05 03 	call	0x60a	; 0x60a <LCD_displayString>
}
     704:	0f 90       	pop	r0
     706:	0f 90       	pop	r0
     708:	0f 90       	pop	r0
     70a:	0f 90       	pop	r0
     70c:	cf 91       	pop	r28
     70e:	df 91       	pop	r29
     710:	08 95       	ret

00000712 <LCD_intgerToString>:
/*
 * Description :
 * Display the required decimal value on the screen
 */
void LCD_intgerToString(int data)
{
     712:	df 93       	push	r29
     714:	cf 93       	push	r28
     716:	cd b7       	in	r28, 0x3d	; 61
     718:	de b7       	in	r29, 0x3e	; 62
     71a:	62 97       	sbiw	r28, 0x12	; 18
     71c:	0f b6       	in	r0, 0x3f	; 63
     71e:	f8 94       	cli
     720:	de bf       	out	0x3e, r29	; 62
     722:	0f be       	out	0x3f, r0	; 63
     724:	cd bf       	out	0x3d, r28	; 61
     726:	9a 8b       	std	Y+18, r25	; 0x12
     728:	89 8b       	std	Y+17, r24	; 0x11
   char buff[16]; /* String to hold the ascii result */
   itoa(data,buff,10); /* Use itoa C function to convert the data to its corresponding ASCII value, 10 for decimal */
     72a:	89 89       	ldd	r24, Y+17	; 0x11
     72c:	9a 89       	ldd	r25, Y+18	; 0x12
     72e:	9e 01       	movw	r18, r28
     730:	2f 5f       	subi	r18, 0xFF	; 255
     732:	3f 4f       	sbci	r19, 0xFF	; 255
     734:	b9 01       	movw	r22, r18
     736:	4a e0       	ldi	r20, 0x0A	; 10
     738:	50 e0       	ldi	r21, 0x00	; 0
     73a:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <itoa>
   LCD_displayString(buff); /* Display the string */
     73e:	ce 01       	movw	r24, r28
     740:	01 96       	adiw	r24, 0x01	; 1
     742:	0e 94 05 03 	call	0x60a	; 0x60a <LCD_displayString>
}
     746:	62 96       	adiw	r28, 0x12	; 18
     748:	0f b6       	in	r0, 0x3f	; 63
     74a:	f8 94       	cli
     74c:	de bf       	out	0x3e, r29	; 62
     74e:	0f be       	out	0x3f, r0	; 63
     750:	cd bf       	out	0x3d, r28	; 61
     752:	cf 91       	pop	r28
     754:	df 91       	pop	r29
     756:	08 95       	ret

00000758 <LCD_clearScreen>:
/*
 * Description :
 * Send the clear screen command
 */
void LCD_clearScreen(void)
{
     758:	df 93       	push	r29
     75a:	cf 93       	push	r28
     75c:	cd b7       	in	r28, 0x3d	; 61
     75e:	de b7       	in	r29, 0x3e	; 62
	LCD_sendCommand(LCD_CLEAR_COMMAND); /* Send clear display command */
     760:	81 e0       	ldi	r24, 0x01	; 1
     762:	0e 94 99 02 	call	0x532	; 0x532 <LCD_sendCommand>
}
     766:	cf 91       	pop	r28
     768:	df 91       	pop	r29
     76a:	08 95       	ret

0000076c <main>:

u8_t  IndexPassword;



int main(void){
     76c:	df 93       	push	r29
     76e:	cf 93       	push	r28
     770:	cd b7       	in	r28, 0x3d	; 61
     772:	de b7       	in	r29, 0x3e	; 62

	gu8_option =0;
     774:	10 92 38 01 	sts	0x0138, r1

	  DelayTimer_8bits_Init ( &delayTimer2_milli , TIMER2_INDEX_ARRAY);
     778:	8b e0       	ldi	r24, 0x0B	; 11
     77a:	91 e0       	ldi	r25, 0x01	; 1
     77c:	61 e0       	ldi	r22, 0x01	; 1
     77e:	0e 94 9e 0a 	call	0x153c	; 0x153c <DelayTimer_8bits_Init>
	  DelayTimer_8bits_Init ( &delayTimer0_milli , TIMER0_INDEX_ARRAY);
     782:	87 e0       	ldi	r24, 0x07	; 7
     784:	91 e0       	ldi	r25, 0x01	; 1
     786:	60 e0       	ldi	r22, 0x00	; 0
     788:	0e 94 9e 0a 	call	0x153c	; 0x153c <DelayTimer_8bits_Init>

	  OverflowTimer_16bits_Init(MTIMER_PRESCALER_1024);
     78c:	85 e0       	ldi	r24, 0x05	; 5
     78e:	0e 94 c4 0c 	call	0x1988	; 0x1988 <OverflowTimer_16bits_Init>

	  UART_init(&MCU1);
     792:	8b ef       	ldi	r24, 0xFB	; 251
     794:	90 e0       	ldi	r25, 0x00	; 0
     796:	0e 94 49 00 	call	0x92	; 0x92 <UART_init>

	  LCD_init();
     79a:	0e 94 71 02 	call	0x4e2	; 0x4e2 <LCD_init>
     79e:	17 c0       	rjmp	.+46     	; 0x7ce <main+0x62>


					//if( (gu8_option == 0) ){


						LCD_displayStringRowColumn(0, 0, "+: Open Door");
     7a0:	20 e6       	ldi	r18, 0x60	; 96
     7a2:	30 e0       	ldi	r19, 0x00	; 0
     7a4:	80 e0       	ldi	r24, 0x00	; 0
     7a6:	60 e0       	ldi	r22, 0x00	; 0
     7a8:	a9 01       	movw	r20, r18
     7aa:	0e 94 70 03 	call	0x6e0	; 0x6e0 <LCD_displayStringRowColumn>
						LCD_displayStringRowColumn(1, 0, "-: Change Pass");
     7ae:	2d e6       	ldi	r18, 0x6D	; 109
     7b0:	30 e0       	ldi	r19, 0x00	; 0
     7b2:	81 e0       	ldi	r24, 0x01	; 1
     7b4:	60 e0       	ldi	r22, 0x00	; 0
     7b6:	a9 01       	movw	r20, r18
     7b8:	0e 94 70 03 	call	0x6e0	; 0x6e0 <LCD_displayStringRowColumn>

						gu8_option = KEYPAD_getPressedKey(); /*get the chose option from user*/
     7bc:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <KEYPAD_getPressedKey>
     7c0:	80 93 38 01 	sts	0x0138, r24
						DelayTimer_8bits_synchrounous( _500_milli_sec, TIMER2_INDEX_ARRAY);
     7c4:	84 ef       	ldi	r24, 0xF4	; 244
     7c6:	91 e0       	ldi	r25, 0x01	; 1
     7c8:	61 e0       	ldi	r22, 0x01	; 1
     7ca:	0e 94 0d 0b 	call	0x161a	; 0x161a <DelayTimer_8bits_synchrounous>

				//gu8_option = KEYPAD_getPressedKey(); /*get the chose option from user*/
				//DelayTimer_8bits_synchrounous( _500_milli_sec, TIMER2_INDEX_ARRAY);


				while( (gu8_option != '+') || (gu8_option != '-') ){
     7ce:	80 91 38 01 	lds	r24, 0x0138
     7d2:	8b 32       	cpi	r24, 0x2B	; 43
     7d4:	29 f7       	brne	.-54     	; 0x7a0 <main+0x34>
     7d6:	80 91 38 01 	lds	r24, 0x0138
     7da:	8d 32       	cpi	r24, 0x2D	; 45
     7dc:	09 f7       	brne	.-62     	; 0x7a0 <main+0x34>
     7de:	08 c0       	rjmp	.+16     	; 0x7f0 <main+0x84>
			}/********************** End of while************************/


					while(gu8_option == '+'){

						Enter_Password_MainPage();
     7e0:	0e 94 54 06 	call	0xca8	; 0xca8 <Enter_Password_MainPage>
						Store_EEPROM_Password(); /*store the correct password automatically*/
     7e4:	0e 94 06 07 	call	0xe0c	; 0xe0c <Store_EEPROM_Password>
                        Check_Entered_Password();/*check the entered maximum three times  */
     7e8:	0e 94 2a 07 	call	0xe54	; 0xe54 <Check_Entered_Password>

						Open_Door_MainPage();
     7ec:	0e 94 b4 06 	call	0xd68	; 0xd68 <Open_Door_MainPage>


			}/********************** End of while************************/


					while(gu8_option == '+'){
     7f0:	80 91 38 01 	lds	r24, 0x0138
     7f4:	8b 32       	cpi	r24, 0x2B	; 43
     7f6:	a1 f3       	breq	.-24     	; 0x7e0 <main+0x74>
     7f8:	1d c0       	rjmp	.+58     	; 0x834 <main+0xc8>
					}/********************** End of while(gu8_option == '+') ************************/


					while(gu8_option == '-'){

						LCD_displayStringRowColumn(0, 0, "Enter old");
     7fa:	2c e7       	ldi	r18, 0x7C	; 124
     7fc:	30 e0       	ldi	r19, 0x00	; 0
     7fe:	80 e0       	ldi	r24, 0x00	; 0
     800:	60 e0       	ldi	r22, 0x00	; 0
     802:	a9 01       	movw	r20, r18
     804:	0e 94 70 03 	call	0x6e0	; 0x6e0 <LCD_displayStringRowColumn>
						LCD_displayStringRowColumn(1, 0, "password");
     808:	26 e8       	ldi	r18, 0x86	; 134
     80a:	30 e0       	ldi	r19, 0x00	; 0
     80c:	81 e0       	ldi	r24, 0x01	; 1
     80e:	60 e0       	ldi	r22, 0x00	; 0
     810:	a9 01       	movw	r20, r18
     812:	0e 94 70 03 	call	0x6e0	; 0x6e0 <LCD_displayStringRowColumn>
						DelayTimer_8bits_synchrounous( _500_milli_sec, TIMER2_INDEX_ARRAY);
     816:	84 ef       	ldi	r24, 0xF4	; 244
     818:	91 e0       	ldi	r25, 0x01	; 1
     81a:	61 e0       	ldi	r22, 0x01	; 1
     81c:	0e 94 0d 0b 	call	0x161a	; 0x161a <DelayTimer_8bits_synchrounous>

						Enter_Password_MainPage();
     820:	0e 94 54 06 	call	0xca8	; 0xca8 <Enter_Password_MainPage>
						Store_EEPROM_Password(); /*store the correct password automatically*/
     824:	0e 94 06 07 	call	0xe0c	; 0xe0c <Store_EEPROM_Password>
                        Check_Entered_Password();/*check the entered maximum three times  */
     828:	0e 94 2a 07 	call	0xe54	; 0xe54 <Check_Entered_Password>

                        Change_Password();
     82c:	0e 94 ae 07 	call	0xf5c	; 0xf5c <Change_Password>
                        Send_Password_MC2(); /* send the new password to the mc2 to be stored in eeprom */
     830:	0e 94 00 08 	call	0x1000	; 0x1000 <Send_Password_MC2>

						Open_Door_MainPage();
					}/********************** End of while(gu8_option == '+') ************************/


					while(gu8_option == '-'){
     834:	80 91 38 01 	lds	r24, 0x0138
     838:	8d 32       	cpi	r24, 0x2D	; 45
     83a:	f9 f2       	breq	.-66     	; 0x7fa <main+0x8e>
     83c:	c8 cf       	rjmp	.-112    	; 0x7ce <main+0x62>

0000083e <mdio_setPinStatus>:
{(u8_t *)&MDIO_DDRD , (u8_t *)&MDIO_PORTD , (u8_t *)&MDIO_PIND}

};

/**************************************************************************************************************************************/
 void  mdio_setPinStatus(DioPort_t au8_port, DioChannel_t au8_pin, DioPinState_t au8_status){
     83e:	df 93       	push	r29
     840:	cf 93       	push	r28
     842:	00 d0       	rcall	.+0      	; 0x844 <mdio_setPinStatus+0x6>
     844:	00 d0       	rcall	.+0      	; 0x846 <mdio_setPinStatus+0x8>
     846:	0f 92       	push	r0
     848:	cd b7       	in	r28, 0x3d	; 61
     84a:	de b7       	in	r29, 0x3e	; 62
     84c:	89 83       	std	Y+1, r24	; 0x01
     84e:	6a 83       	std	Y+2, r22	; 0x02
     850:	4b 83       	std	Y+3, r20	; 0x03
    //assert((au8_port>=MIN_NUM_PORT) && (au8_port <= MAX_NUM_PORT));
   // assert((au8_pin >= MIN_NUM_PIN) && (au8_pin  <= MAX_NUM_PIN));
   // assert((au8_status >= DIO_MIN_STATE_VALUE) && (au8_status <= DIO_MAX_STATE_VALUE));


	switch(au8_status){
     852:	8b 81       	ldd	r24, Y+3	; 0x03
     854:	28 2f       	mov	r18, r24
     856:	30 e0       	ldi	r19, 0x00	; 0
     858:	3d 83       	std	Y+5, r19	; 0x05
     85a:	2c 83       	std	Y+4, r18	; 0x04
     85c:	8c 81       	ldd	r24, Y+4	; 0x04
     85e:	9d 81       	ldd	r25, Y+5	; 0x05
     860:	81 30       	cpi	r24, 0x01	; 1
     862:	91 05       	cpc	r25, r1
     864:	d1 f1       	breq	.+116    	; 0x8da <mdio_setPinStatus+0x9c>
     866:	2c 81       	ldd	r18, Y+4	; 0x04
     868:	3d 81       	ldd	r19, Y+5	; 0x05
     86a:	22 30       	cpi	r18, 0x02	; 2
     86c:	31 05       	cpc	r19, r1
     86e:	09 f4       	brne	.+2      	; 0x872 <mdio_setPinStatus+0x34>
     870:	64 c0       	rjmp	.+200    	; 0x93a <mdio_setPinStatus+0xfc>
     872:	8c 81       	ldd	r24, Y+4	; 0x04
     874:	9d 81       	ldd	r25, Y+5	; 0x05
     876:	00 97       	sbiw	r24, 0x00	; 0
     878:	09 f0       	breq	.+2      	; 0x87c <mdio_setPinStatus+0x3e>
     87a:	bd c0       	rjmp	.+378    	; 0x9f6 <mdio_setPinStatus+0x1b8>

	    case DIO_OUTPUT_PIN:

		      SET_BIT(*DIO_PORT_REG[au8_port][DDR],(au8_pin));  /*accessing the DDR register of a specific port */
     87c:	89 81       	ldd	r24, Y+1	; 0x01
     87e:	28 2f       	mov	r18, r24
     880:	30 e0       	ldi	r19, 0x00	; 0
     882:	c9 01       	movw	r24, r18
     884:	88 0f       	add	r24, r24
     886:	99 1f       	adc	r25, r25
     888:	82 0f       	add	r24, r18
     88a:	93 1f       	adc	r25, r19
     88c:	88 0f       	add	r24, r24
     88e:	99 1f       	adc	r25, r25
     890:	fc 01       	movw	r30, r24
     892:	ec 5e       	subi	r30, 0xEC	; 236
     894:	fe 4f       	sbci	r31, 0xFE	; 254
     896:	a0 81       	ld	r26, Z
     898:	b1 81       	ldd	r27, Z+1	; 0x01
     89a:	89 81       	ldd	r24, Y+1	; 0x01
     89c:	28 2f       	mov	r18, r24
     89e:	30 e0       	ldi	r19, 0x00	; 0
     8a0:	c9 01       	movw	r24, r18
     8a2:	88 0f       	add	r24, r24
     8a4:	99 1f       	adc	r25, r25
     8a6:	82 0f       	add	r24, r18
     8a8:	93 1f       	adc	r25, r19
     8aa:	88 0f       	add	r24, r24
     8ac:	99 1f       	adc	r25, r25
     8ae:	fc 01       	movw	r30, r24
     8b0:	ec 5e       	subi	r30, 0xEC	; 236
     8b2:	fe 4f       	sbci	r31, 0xFE	; 254
     8b4:	01 90       	ld	r0, Z+
     8b6:	f0 81       	ld	r31, Z
     8b8:	e0 2d       	mov	r30, r0
     8ba:	80 81       	ld	r24, Z
     8bc:	48 2f       	mov	r20, r24
     8be:	8a 81       	ldd	r24, Y+2	; 0x02
     8c0:	28 2f       	mov	r18, r24
     8c2:	30 e0       	ldi	r19, 0x00	; 0
     8c4:	81 e0       	ldi	r24, 0x01	; 1
     8c6:	90 e0       	ldi	r25, 0x00	; 0
     8c8:	02 2e       	mov	r0, r18
     8ca:	02 c0       	rjmp	.+4      	; 0x8d0 <mdio_setPinStatus+0x92>
     8cc:	88 0f       	add	r24, r24
     8ce:	99 1f       	adc	r25, r25
     8d0:	0a 94       	dec	r0
     8d2:	e2 f7       	brpl	.-8      	; 0x8cc <mdio_setPinStatus+0x8e>
     8d4:	84 2b       	or	r24, r20
     8d6:	8c 93       	st	X, r24
     8d8:	8e c0       	rjmp	.+284    	; 0x9f6 <mdio_setPinStatus+0x1b8>
		       break; /* break from the DIO_OUTPUT_PIN  case */  /* example --> *DIO_PORT_REG[PORTA][DDR]  */

	    case DIO_INPUT_FLOAT_PIN:

	    	 CLEAR_BIT(*DIO_PORT_REG[au8_port][DDR],(au8_pin));  /*accessing the DDR register of a specific port*/
     8da:	89 81       	ldd	r24, Y+1	; 0x01
     8dc:	28 2f       	mov	r18, r24
     8de:	30 e0       	ldi	r19, 0x00	; 0
     8e0:	c9 01       	movw	r24, r18
     8e2:	88 0f       	add	r24, r24
     8e4:	99 1f       	adc	r25, r25
     8e6:	82 0f       	add	r24, r18
     8e8:	93 1f       	adc	r25, r19
     8ea:	88 0f       	add	r24, r24
     8ec:	99 1f       	adc	r25, r25
     8ee:	fc 01       	movw	r30, r24
     8f0:	ec 5e       	subi	r30, 0xEC	; 236
     8f2:	fe 4f       	sbci	r31, 0xFE	; 254
     8f4:	a0 81       	ld	r26, Z
     8f6:	b1 81       	ldd	r27, Z+1	; 0x01
     8f8:	89 81       	ldd	r24, Y+1	; 0x01
     8fa:	28 2f       	mov	r18, r24
     8fc:	30 e0       	ldi	r19, 0x00	; 0
     8fe:	c9 01       	movw	r24, r18
     900:	88 0f       	add	r24, r24
     902:	99 1f       	adc	r25, r25
     904:	82 0f       	add	r24, r18
     906:	93 1f       	adc	r25, r19
     908:	88 0f       	add	r24, r24
     90a:	99 1f       	adc	r25, r25
     90c:	fc 01       	movw	r30, r24
     90e:	ec 5e       	subi	r30, 0xEC	; 236
     910:	fe 4f       	sbci	r31, 0xFE	; 254
     912:	01 90       	ld	r0, Z+
     914:	f0 81       	ld	r31, Z
     916:	e0 2d       	mov	r30, r0
     918:	80 81       	ld	r24, Z
     91a:	48 2f       	mov	r20, r24
     91c:	8a 81       	ldd	r24, Y+2	; 0x02
     91e:	28 2f       	mov	r18, r24
     920:	30 e0       	ldi	r19, 0x00	; 0
     922:	81 e0       	ldi	r24, 0x01	; 1
     924:	90 e0       	ldi	r25, 0x00	; 0
     926:	02 2e       	mov	r0, r18
     928:	02 c0       	rjmp	.+4      	; 0x92e <mdio_setPinStatus+0xf0>
     92a:	88 0f       	add	r24, r24
     92c:	99 1f       	adc	r25, r25
     92e:	0a 94       	dec	r0
     930:	e2 f7       	brpl	.-8      	; 0x92a <mdio_setPinStatus+0xec>
     932:	80 95       	com	r24
     934:	84 23       	and	r24, r20
     936:	8c 93       	st	X, r24
     938:	5e c0       	rjmp	.+188    	; 0x9f6 <mdio_setPinStatus+0x1b8>
	    	  break;/* break from the DIO_INPUT_FLOAT_PIN case  */


	    case DIO_INPUT_PULLUP_PIN:

	    	CLEAR_BIT(*DIO_PORT_REG[au8_port][DDR],(au8_pin) ); /*accessing the DDR register of a specific port*/
     93a:	89 81       	ldd	r24, Y+1	; 0x01
     93c:	28 2f       	mov	r18, r24
     93e:	30 e0       	ldi	r19, 0x00	; 0
     940:	c9 01       	movw	r24, r18
     942:	88 0f       	add	r24, r24
     944:	99 1f       	adc	r25, r25
     946:	82 0f       	add	r24, r18
     948:	93 1f       	adc	r25, r19
     94a:	88 0f       	add	r24, r24
     94c:	99 1f       	adc	r25, r25
     94e:	fc 01       	movw	r30, r24
     950:	ec 5e       	subi	r30, 0xEC	; 236
     952:	fe 4f       	sbci	r31, 0xFE	; 254
     954:	a0 81       	ld	r26, Z
     956:	b1 81       	ldd	r27, Z+1	; 0x01
     958:	89 81       	ldd	r24, Y+1	; 0x01
     95a:	28 2f       	mov	r18, r24
     95c:	30 e0       	ldi	r19, 0x00	; 0
     95e:	c9 01       	movw	r24, r18
     960:	88 0f       	add	r24, r24
     962:	99 1f       	adc	r25, r25
     964:	82 0f       	add	r24, r18
     966:	93 1f       	adc	r25, r19
     968:	88 0f       	add	r24, r24
     96a:	99 1f       	adc	r25, r25
     96c:	fc 01       	movw	r30, r24
     96e:	ec 5e       	subi	r30, 0xEC	; 236
     970:	fe 4f       	sbci	r31, 0xFE	; 254
     972:	01 90       	ld	r0, Z+
     974:	f0 81       	ld	r31, Z
     976:	e0 2d       	mov	r30, r0
     978:	80 81       	ld	r24, Z
     97a:	48 2f       	mov	r20, r24
     97c:	8a 81       	ldd	r24, Y+2	; 0x02
     97e:	28 2f       	mov	r18, r24
     980:	30 e0       	ldi	r19, 0x00	; 0
     982:	81 e0       	ldi	r24, 0x01	; 1
     984:	90 e0       	ldi	r25, 0x00	; 0
     986:	02 c0       	rjmp	.+4      	; 0x98c <mdio_setPinStatus+0x14e>
     988:	88 0f       	add	r24, r24
     98a:	99 1f       	adc	r25, r25
     98c:	2a 95       	dec	r18
     98e:	e2 f7       	brpl	.-8      	; 0x988 <mdio_setPinStatus+0x14a>
     990:	80 95       	com	r24
     992:	84 23       	and	r24, r20
     994:	8c 93       	st	X, r24
			SET_BIT(*DIO_PORT_REG[au8_port][PORT],(au8_pin)) ;  /*accessing the PORT register of a specific port*/
     996:	89 81       	ldd	r24, Y+1	; 0x01
     998:	28 2f       	mov	r18, r24
     99a:	30 e0       	ldi	r19, 0x00	; 0
     99c:	c9 01       	movw	r24, r18
     99e:	88 0f       	add	r24, r24
     9a0:	99 1f       	adc	r25, r25
     9a2:	82 0f       	add	r24, r18
     9a4:	93 1f       	adc	r25, r19
     9a6:	01 96       	adiw	r24, 0x01	; 1
     9a8:	88 0f       	add	r24, r24
     9aa:	99 1f       	adc	r25, r25
     9ac:	fc 01       	movw	r30, r24
     9ae:	ec 5e       	subi	r30, 0xEC	; 236
     9b0:	fe 4f       	sbci	r31, 0xFE	; 254
     9b2:	a0 81       	ld	r26, Z
     9b4:	b1 81       	ldd	r27, Z+1	; 0x01
     9b6:	89 81       	ldd	r24, Y+1	; 0x01
     9b8:	28 2f       	mov	r18, r24
     9ba:	30 e0       	ldi	r19, 0x00	; 0
     9bc:	c9 01       	movw	r24, r18
     9be:	88 0f       	add	r24, r24
     9c0:	99 1f       	adc	r25, r25
     9c2:	82 0f       	add	r24, r18
     9c4:	93 1f       	adc	r25, r19
     9c6:	01 96       	adiw	r24, 0x01	; 1
     9c8:	88 0f       	add	r24, r24
     9ca:	99 1f       	adc	r25, r25
     9cc:	fc 01       	movw	r30, r24
     9ce:	ec 5e       	subi	r30, 0xEC	; 236
     9d0:	fe 4f       	sbci	r31, 0xFE	; 254
     9d2:	01 90       	ld	r0, Z+
     9d4:	f0 81       	ld	r31, Z
     9d6:	e0 2d       	mov	r30, r0
     9d8:	80 81       	ld	r24, Z
     9da:	48 2f       	mov	r20, r24
     9dc:	8a 81       	ldd	r24, Y+2	; 0x02
     9de:	28 2f       	mov	r18, r24
     9e0:	30 e0       	ldi	r19, 0x00	; 0
     9e2:	81 e0       	ldi	r24, 0x01	; 1
     9e4:	90 e0       	ldi	r25, 0x00	; 0
     9e6:	02 2e       	mov	r0, r18
     9e8:	02 c0       	rjmp	.+4      	; 0x9ee <mdio_setPinStatus+0x1b0>
     9ea:	88 0f       	add	r24, r24
     9ec:	99 1f       	adc	r25, r25
     9ee:	0a 94       	dec	r0
     9f0:	e2 f7       	brpl	.-8      	; 0x9ea <mdio_setPinStatus+0x1ac>
     9f2:	84 2b       	or	r24, r20
     9f4:	8c 93       	st	X, r24
             break; /* break from the DIO_INPUT_PULLUP_PIN case*/
	}
	  return;
}
     9f6:	0f 90       	pop	r0
     9f8:	0f 90       	pop	r0
     9fa:	0f 90       	pop	r0
     9fc:	0f 90       	pop	r0
     9fe:	0f 90       	pop	r0
     a00:	cf 91       	pop	r28
     a02:	df 91       	pop	r29
     a04:	08 95       	ret

00000a06 <mdio_setPinValue>:
/**************************************************************************************************************************************/


/**************************************************************************************************************************************/
void  mdio_setPinValue(DioPort_t au8_port, DioChannel_t au8_pin, DioOutputValue_t au8_value){
     a06:	df 93       	push	r29
     a08:	cf 93       	push	r28
     a0a:	00 d0       	rcall	.+0      	; 0xa0c <mdio_setPinValue+0x6>
     a0c:	00 d0       	rcall	.+0      	; 0xa0e <mdio_setPinValue+0x8>
     a0e:	0f 92       	push	r0
     a10:	cd b7       	in	r28, 0x3d	; 61
     a12:	de b7       	in	r29, 0x3e	; 62
     a14:	89 83       	std	Y+1, r24	; 0x01
     a16:	6a 83       	std	Y+2, r22	; 0x02
     a18:	4b 83       	std	Y+3, r20	; 0x03

	//assert((au8_port>=MIN_NUM_PORT) && (au8_port <= MAX_NUM_PORT));
	//assert((au8_pin >= MIN_NUM_PIN) && (au8_pin  <= MAX_NUM_PIN));
    //assert((au8_value == DIO_HIGH)||(au8_value == DIO_LOW));

	switch(au8_value){
     a1a:	8b 81       	ldd	r24, Y+3	; 0x03
     a1c:	28 2f       	mov	r18, r24
     a1e:	30 e0       	ldi	r19, 0x00	; 0
     a20:	3d 83       	std	Y+5, r19	; 0x05
     a22:	2c 83       	std	Y+4, r18	; 0x04
     a24:	8c 81       	ldd	r24, Y+4	; 0x04
     a26:	9d 81       	ldd	r25, Y+5	; 0x05
     a28:	00 97       	sbiw	r24, 0x00	; 0
     a2a:	31 f0       	breq	.+12     	; 0xa38 <mdio_setPinValue+0x32>
     a2c:	2c 81       	ldd	r18, Y+4	; 0x04
     a2e:	3d 81       	ldd	r19, Y+5	; 0x05
     a30:	21 30       	cpi	r18, 0x01	; 1
     a32:	31 05       	cpc	r19, r1
     a34:	99 f1       	breq	.+102    	; 0xa9c <mdio_setPinValue+0x96>
     a36:	62 c0       	rjmp	.+196    	; 0xafc <mdio_setPinValue+0xf6>

	case DIO_LOW_OUTPUT:
		CLEAR_BIT(*DIO_PORT_REG[au8_port][PORT],(au8_pin)) ;
     a38:	89 81       	ldd	r24, Y+1	; 0x01
     a3a:	28 2f       	mov	r18, r24
     a3c:	30 e0       	ldi	r19, 0x00	; 0
     a3e:	c9 01       	movw	r24, r18
     a40:	88 0f       	add	r24, r24
     a42:	99 1f       	adc	r25, r25
     a44:	82 0f       	add	r24, r18
     a46:	93 1f       	adc	r25, r19
     a48:	01 96       	adiw	r24, 0x01	; 1
     a4a:	88 0f       	add	r24, r24
     a4c:	99 1f       	adc	r25, r25
     a4e:	fc 01       	movw	r30, r24
     a50:	ec 5e       	subi	r30, 0xEC	; 236
     a52:	fe 4f       	sbci	r31, 0xFE	; 254
     a54:	a0 81       	ld	r26, Z
     a56:	b1 81       	ldd	r27, Z+1	; 0x01
     a58:	89 81       	ldd	r24, Y+1	; 0x01
     a5a:	28 2f       	mov	r18, r24
     a5c:	30 e0       	ldi	r19, 0x00	; 0
     a5e:	c9 01       	movw	r24, r18
     a60:	88 0f       	add	r24, r24
     a62:	99 1f       	adc	r25, r25
     a64:	82 0f       	add	r24, r18
     a66:	93 1f       	adc	r25, r19
     a68:	01 96       	adiw	r24, 0x01	; 1
     a6a:	88 0f       	add	r24, r24
     a6c:	99 1f       	adc	r25, r25
     a6e:	fc 01       	movw	r30, r24
     a70:	ec 5e       	subi	r30, 0xEC	; 236
     a72:	fe 4f       	sbci	r31, 0xFE	; 254
     a74:	01 90       	ld	r0, Z+
     a76:	f0 81       	ld	r31, Z
     a78:	e0 2d       	mov	r30, r0
     a7a:	80 81       	ld	r24, Z
     a7c:	48 2f       	mov	r20, r24
     a7e:	8a 81       	ldd	r24, Y+2	; 0x02
     a80:	28 2f       	mov	r18, r24
     a82:	30 e0       	ldi	r19, 0x00	; 0
     a84:	81 e0       	ldi	r24, 0x01	; 1
     a86:	90 e0       	ldi	r25, 0x00	; 0
     a88:	02 2e       	mov	r0, r18
     a8a:	02 c0       	rjmp	.+4      	; 0xa90 <mdio_setPinValue+0x8a>
     a8c:	88 0f       	add	r24, r24
     a8e:	99 1f       	adc	r25, r25
     a90:	0a 94       	dec	r0
     a92:	e2 f7       	brpl	.-8      	; 0xa8c <mdio_setPinValue+0x86>
     a94:	80 95       	com	r24
     a96:	84 23       	and	r24, r20
     a98:	8c 93       	st	X, r24
     a9a:	30 c0       	rjmp	.+96     	; 0xafc <mdio_setPinValue+0xf6>
		break; /* break from the DIO_LOW_OUTPUT case*/

	case DIO_HIGH_OUTPUT:
		SET_BIT(*DIO_PORT_REG[au8_port][PORT],(au8_pin)) ;
     a9c:	89 81       	ldd	r24, Y+1	; 0x01
     a9e:	28 2f       	mov	r18, r24
     aa0:	30 e0       	ldi	r19, 0x00	; 0
     aa2:	c9 01       	movw	r24, r18
     aa4:	88 0f       	add	r24, r24
     aa6:	99 1f       	adc	r25, r25
     aa8:	82 0f       	add	r24, r18
     aaa:	93 1f       	adc	r25, r19
     aac:	01 96       	adiw	r24, 0x01	; 1
     aae:	88 0f       	add	r24, r24
     ab0:	99 1f       	adc	r25, r25
     ab2:	fc 01       	movw	r30, r24
     ab4:	ec 5e       	subi	r30, 0xEC	; 236
     ab6:	fe 4f       	sbci	r31, 0xFE	; 254
     ab8:	a0 81       	ld	r26, Z
     aba:	b1 81       	ldd	r27, Z+1	; 0x01
     abc:	89 81       	ldd	r24, Y+1	; 0x01
     abe:	28 2f       	mov	r18, r24
     ac0:	30 e0       	ldi	r19, 0x00	; 0
     ac2:	c9 01       	movw	r24, r18
     ac4:	88 0f       	add	r24, r24
     ac6:	99 1f       	adc	r25, r25
     ac8:	82 0f       	add	r24, r18
     aca:	93 1f       	adc	r25, r19
     acc:	01 96       	adiw	r24, 0x01	; 1
     ace:	88 0f       	add	r24, r24
     ad0:	99 1f       	adc	r25, r25
     ad2:	fc 01       	movw	r30, r24
     ad4:	ec 5e       	subi	r30, 0xEC	; 236
     ad6:	fe 4f       	sbci	r31, 0xFE	; 254
     ad8:	01 90       	ld	r0, Z+
     ada:	f0 81       	ld	r31, Z
     adc:	e0 2d       	mov	r30, r0
     ade:	80 81       	ld	r24, Z
     ae0:	48 2f       	mov	r20, r24
     ae2:	8a 81       	ldd	r24, Y+2	; 0x02
     ae4:	28 2f       	mov	r18, r24
     ae6:	30 e0       	ldi	r19, 0x00	; 0
     ae8:	81 e0       	ldi	r24, 0x01	; 1
     aea:	90 e0       	ldi	r25, 0x00	; 0
     aec:	02 2e       	mov	r0, r18
     aee:	02 c0       	rjmp	.+4      	; 0xaf4 <mdio_setPinValue+0xee>
     af0:	88 0f       	add	r24, r24
     af2:	99 1f       	adc	r25, r25
     af4:	0a 94       	dec	r0
     af6:	e2 f7       	brpl	.-8      	; 0xaf0 <mdio_setPinValue+0xea>
     af8:	84 2b       	or	r24, r20
     afa:	8c 93       	st	X, r24
		break; /* break from the DIO_HIGH_OUTPUT case*/
	}
	return;
}
     afc:	0f 90       	pop	r0
     afe:	0f 90       	pop	r0
     b00:	0f 90       	pop	r0
     b02:	0f 90       	pop	r0
     b04:	0f 90       	pop	r0
     b06:	cf 91       	pop	r28
     b08:	df 91       	pop	r29
     b0a:	08 95       	ret

00000b0c <mdio_togglePinValue>:

/**************************************************************************************************************************************/


/**************************************************************************************************************************************/
void  mdio_togglePinValue(DioPort_t au8_port, DioChannel_t au8_pin){
     b0c:	df 93       	push	r29
     b0e:	cf 93       	push	r28
     b10:	00 d0       	rcall	.+0      	; 0xb12 <mdio_togglePinValue+0x6>
     b12:	cd b7       	in	r28, 0x3d	; 61
     b14:	de b7       	in	r29, 0x3e	; 62
     b16:	89 83       	std	Y+1, r24	; 0x01
     b18:	6a 83       	std	Y+2, r22	; 0x02

	//assert((au8_port>=MIN_NUM_PORT) && (au8_port <= MAX_NUM_PORT));
	//assert((au8_pin >= MIN_NUM_PIN) && (au8_pin  <= MAX_NUM_PIN));

	TOGGLE_BIT(*DIO_PORT_REG[au8_port][PORT],(au8_pin));
     b1a:	89 81       	ldd	r24, Y+1	; 0x01
     b1c:	28 2f       	mov	r18, r24
     b1e:	30 e0       	ldi	r19, 0x00	; 0
     b20:	c9 01       	movw	r24, r18
     b22:	88 0f       	add	r24, r24
     b24:	99 1f       	adc	r25, r25
     b26:	82 0f       	add	r24, r18
     b28:	93 1f       	adc	r25, r19
     b2a:	01 96       	adiw	r24, 0x01	; 1
     b2c:	88 0f       	add	r24, r24
     b2e:	99 1f       	adc	r25, r25
     b30:	fc 01       	movw	r30, r24
     b32:	ec 5e       	subi	r30, 0xEC	; 236
     b34:	fe 4f       	sbci	r31, 0xFE	; 254
     b36:	a0 81       	ld	r26, Z
     b38:	b1 81       	ldd	r27, Z+1	; 0x01
     b3a:	89 81       	ldd	r24, Y+1	; 0x01
     b3c:	28 2f       	mov	r18, r24
     b3e:	30 e0       	ldi	r19, 0x00	; 0
     b40:	c9 01       	movw	r24, r18
     b42:	88 0f       	add	r24, r24
     b44:	99 1f       	adc	r25, r25
     b46:	82 0f       	add	r24, r18
     b48:	93 1f       	adc	r25, r19
     b4a:	01 96       	adiw	r24, 0x01	; 1
     b4c:	88 0f       	add	r24, r24
     b4e:	99 1f       	adc	r25, r25
     b50:	fc 01       	movw	r30, r24
     b52:	ec 5e       	subi	r30, 0xEC	; 236
     b54:	fe 4f       	sbci	r31, 0xFE	; 254
     b56:	01 90       	ld	r0, Z+
     b58:	f0 81       	ld	r31, Z
     b5a:	e0 2d       	mov	r30, r0
     b5c:	80 81       	ld	r24, Z
     b5e:	48 2f       	mov	r20, r24
     b60:	8a 81       	ldd	r24, Y+2	; 0x02
     b62:	28 2f       	mov	r18, r24
     b64:	30 e0       	ldi	r19, 0x00	; 0
     b66:	81 e0       	ldi	r24, 0x01	; 1
     b68:	90 e0       	ldi	r25, 0x00	; 0
     b6a:	02 2e       	mov	r0, r18
     b6c:	02 c0       	rjmp	.+4      	; 0xb72 <mdio_togglePinValue+0x66>
     b6e:	88 0f       	add	r24, r24
     b70:	99 1f       	adc	r25, r25
     b72:	0a 94       	dec	r0
     b74:	e2 f7       	brpl	.-8      	; 0xb6e <mdio_togglePinValue+0x62>
     b76:	84 27       	eor	r24, r20
     b78:	8c 93       	st	X, r24
	return;
}
     b7a:	0f 90       	pop	r0
     b7c:	0f 90       	pop	r0
     b7e:	cf 91       	pop	r28
     b80:	df 91       	pop	r29
     b82:	08 95       	ret

00000b84 <mdio_getPinValue>:
/**************************************************************************************************************************************/


/**************************************************************************************************************************************/
u8_t  mdio_getPinValue(DioPort_t au8_port, DioChannel_t au8_pin){
     b84:	df 93       	push	r29
     b86:	cf 93       	push	r28
     b88:	00 d0       	rcall	.+0      	; 0xb8a <mdio_getPinValue+0x6>
     b8a:	0f 92       	push	r0
     b8c:	cd b7       	in	r28, 0x3d	; 61
     b8e:	de b7       	in	r29, 0x3e	; 62
     b90:	8a 83       	std	Y+2, r24	; 0x02
     b92:	6b 83       	std	Y+3, r22	; 0x03

	//assert((au8_port>=MIN_NUM_PORT) && (au8_port <= MAX_NUM_PORT));
	//assert((au8_pin >= MIN_NUM_PIN) && (au8_pin  <= MAX_NUM_PIN));

	u8_t value=0;
     b94:	19 82       	std	Y+1, r1	; 0x01


		if(GET_BIT(*DIO_PORT_REG[au8_port][PORT],(au8_pin))){
     b96:	8a 81       	ldd	r24, Y+2	; 0x02
     b98:	28 2f       	mov	r18, r24
     b9a:	30 e0       	ldi	r19, 0x00	; 0
     b9c:	c9 01       	movw	r24, r18
     b9e:	88 0f       	add	r24, r24
     ba0:	99 1f       	adc	r25, r25
     ba2:	82 0f       	add	r24, r18
     ba4:	93 1f       	adc	r25, r19
     ba6:	01 96       	adiw	r24, 0x01	; 1
     ba8:	88 0f       	add	r24, r24
     baa:	99 1f       	adc	r25, r25
     bac:	fc 01       	movw	r30, r24
     bae:	ec 5e       	subi	r30, 0xEC	; 236
     bb0:	fe 4f       	sbci	r31, 0xFE	; 254
     bb2:	01 90       	ld	r0, Z+
     bb4:	f0 81       	ld	r31, Z
     bb6:	e0 2d       	mov	r30, r0
     bb8:	80 81       	ld	r24, Z
     bba:	28 2f       	mov	r18, r24
     bbc:	30 e0       	ldi	r19, 0x00	; 0
     bbe:	8b 81       	ldd	r24, Y+3	; 0x03
     bc0:	88 2f       	mov	r24, r24
     bc2:	90 e0       	ldi	r25, 0x00	; 0
     bc4:	a9 01       	movw	r20, r18
     bc6:	02 c0       	rjmp	.+4      	; 0xbcc <mdio_getPinValue+0x48>
     bc8:	55 95       	asr	r21
     bca:	47 95       	ror	r20
     bcc:	8a 95       	dec	r24
     bce:	e2 f7       	brpl	.-8      	; 0xbc8 <mdio_getPinValue+0x44>
     bd0:	ca 01       	movw	r24, r20
     bd2:	81 70       	andi	r24, 0x01	; 1
     bd4:	90 70       	andi	r25, 0x00	; 0
     bd6:	88 23       	and	r24, r24
     bd8:	19 f0       	breq	.+6      	; 0xbe0 <mdio_getPinValue+0x5c>


		value=DIO_HIGH_OUTPUT;
     bda:	81 e0       	ldi	r24, 0x01	; 1
     bdc:	89 83       	std	Y+1, r24	; 0x01
     bde:	01 c0       	rjmp	.+2      	; 0xbe2 <mdio_getPinValue+0x5e>
		}

		else{

		value=DIO_LOW_OUTPUT;
     be0:	19 82       	std	Y+1, r1	; 0x01
		}

	return value;
     be2:	89 81       	ldd	r24, Y+1	; 0x01
}
     be4:	0f 90       	pop	r0
     be6:	0f 90       	pop	r0
     be8:	0f 90       	pop	r0
     bea:	cf 91       	pop	r28
     bec:	df 91       	pop	r29
     bee:	08 95       	ret

00000bf0 <GPIO_setupPortDirection>:
/**************************************************************************************************************************************/



/**************************************************************************************************************************************/
void GPIO_setupPortDirection(DioPort_t au8_port, GPIO_PortDirectionType au8_direction){
     bf0:	df 93       	push	r29
     bf2:	cf 93       	push	r28
     bf4:	00 d0       	rcall	.+0      	; 0xbf6 <GPIO_setupPortDirection+0x6>
     bf6:	cd b7       	in	r28, 0x3d	; 61
     bf8:	de b7       	in	r29, 0x3e	; 62
     bfa:	89 83       	std	Y+1, r24	; 0x01
     bfc:	6a 83       	std	Y+2, r22	; 0x02

	*DIO_PORT_REG[au8_port][DDR]=au8_direction;
     bfe:	89 81       	ldd	r24, Y+1	; 0x01
     c00:	28 2f       	mov	r18, r24
     c02:	30 e0       	ldi	r19, 0x00	; 0
     c04:	c9 01       	movw	r24, r18
     c06:	88 0f       	add	r24, r24
     c08:	99 1f       	adc	r25, r25
     c0a:	82 0f       	add	r24, r18
     c0c:	93 1f       	adc	r25, r19
     c0e:	88 0f       	add	r24, r24
     c10:	99 1f       	adc	r25, r25
     c12:	fc 01       	movw	r30, r24
     c14:	ec 5e       	subi	r30, 0xEC	; 236
     c16:	fe 4f       	sbci	r31, 0xFE	; 254
     c18:	01 90       	ld	r0, Z+
     c1a:	f0 81       	ld	r31, Z
     c1c:	e0 2d       	mov	r30, r0
     c1e:	8a 81       	ldd	r24, Y+2	; 0x02
     c20:	80 83       	st	Z, r24

}
     c22:	0f 90       	pop	r0
     c24:	0f 90       	pop	r0
     c26:	cf 91       	pop	r28
     c28:	df 91       	pop	r29
     c2a:	08 95       	ret

00000c2c <GPIO_writePort>:




/**************************************************************************************************************************************/
void GPIO_writePort(u8_t au8_port, u8_t au8_value){
     c2c:	df 93       	push	r29
     c2e:	cf 93       	push	r28
     c30:	00 d0       	rcall	.+0      	; 0xc32 <GPIO_writePort+0x6>
     c32:	cd b7       	in	r28, 0x3d	; 61
     c34:	de b7       	in	r29, 0x3e	; 62
     c36:	89 83       	std	Y+1, r24	; 0x01
     c38:	6a 83       	std	Y+2, r22	; 0x02

	*DIO_PORT_REG[au8_port][PORT]=au8_value;
     c3a:	89 81       	ldd	r24, Y+1	; 0x01
     c3c:	28 2f       	mov	r18, r24
     c3e:	30 e0       	ldi	r19, 0x00	; 0
     c40:	c9 01       	movw	r24, r18
     c42:	88 0f       	add	r24, r24
     c44:	99 1f       	adc	r25, r25
     c46:	82 0f       	add	r24, r18
     c48:	93 1f       	adc	r25, r19
     c4a:	01 96       	adiw	r24, 0x01	; 1
     c4c:	88 0f       	add	r24, r24
     c4e:	99 1f       	adc	r25, r25
     c50:	fc 01       	movw	r30, r24
     c52:	ec 5e       	subi	r30, 0xEC	; 236
     c54:	fe 4f       	sbci	r31, 0xFE	; 254
     c56:	01 90       	ld	r0, Z+
     c58:	f0 81       	ld	r31, Z
     c5a:	e0 2d       	mov	r30, r0
     c5c:	8a 81       	ldd	r24, Y+2	; 0x02
     c5e:	80 83       	st	Z, r24

}
     c60:	0f 90       	pop	r0
     c62:	0f 90       	pop	r0
     c64:	cf 91       	pop	r28
     c66:	df 91       	pop	r29
     c68:	08 95       	ret

00000c6a <GPIO_readPort>:




/**************************************************************************************************************************************/
u8_t  GPIO_readPort(u8_t au8_port){
     c6a:	df 93       	push	r29
     c6c:	cf 93       	push	r28
     c6e:	00 d0       	rcall	.+0      	; 0xc70 <GPIO_readPort+0x6>
     c70:	cd b7       	in	r28, 0x3d	; 61
     c72:	de b7       	in	r29, 0x3e	; 62
     c74:	8a 83       	std	Y+2, r24	; 0x02

	u8_t au8_value = DIO_LOW_OUTPUT;
     c76:	19 82       	std	Y+1, r1	; 0x01

	au8_value=*DIO_PORT_REG[au8_port][PIN];
     c78:	8a 81       	ldd	r24, Y+2	; 0x02
     c7a:	28 2f       	mov	r18, r24
     c7c:	30 e0       	ldi	r19, 0x00	; 0
     c7e:	c9 01       	movw	r24, r18
     c80:	88 0f       	add	r24, r24
     c82:	99 1f       	adc	r25, r25
     c84:	82 0f       	add	r24, r18
     c86:	93 1f       	adc	r25, r19
     c88:	88 0f       	add	r24, r24
     c8a:	99 1f       	adc	r25, r25
     c8c:	fc 01       	movw	r30, r24
     c8e:	e8 5e       	subi	r30, 0xE8	; 232
     c90:	fe 4f       	sbci	r31, 0xFE	; 254
     c92:	01 90       	ld	r0, Z+
     c94:	f0 81       	ld	r31, Z
     c96:	e0 2d       	mov	r30, r0
     c98:	80 81       	ld	r24, Z
     c9a:	89 83       	std	Y+1, r24	; 0x01

	return  au8_value;
     c9c:	89 81       	ldd	r24, Y+1	; 0x01

}
     c9e:	0f 90       	pop	r0
     ca0:	0f 90       	pop	r0
     ca2:	cf 91       	pop	r28
     ca4:	df 91       	pop	r29
     ca6:	08 95       	ret

00000ca8 <Enter_Password_MainPage>:
u8_t Num_pass_Entered_Wrong;

u8_t storedPassEEPROM[5];

/*if the user choose open door option*/
void Enter_Password_MainPage(void){
     ca8:	0f 93       	push	r16
     caa:	1f 93       	push	r17
     cac:	df 93       	push	r29
     cae:	cf 93       	push	r28
     cb0:	cd b7       	in	r28, 0x3d	; 61
     cb2:	de b7       	in	r29, 0x3e	; 62

	i=0;
     cb4:	10 92 3a 01 	sts	0x013A, r1
	passCount=0;
     cb8:	10 92 39 01 	sts	0x0139, r1


	LCD_clearScreen(); /*clear screen*/
     cbc:	0e 94 ac 03 	call	0x758	; 0x758 <LCD_clearScreen>
	LCD_displayStringRowColumn(0, 0, "Enter password:");
     cc0:	2f e8       	ldi	r18, 0x8F	; 143
     cc2:	30 e0       	ldi	r19, 0x00	; 0
     cc4:	80 e0       	ldi	r24, 0x00	; 0
     cc6:	60 e0       	ldi	r22, 0x00	; 0
     cc8:	a9 01       	movw	r20, r18
     cca:	0e 94 70 03 	call	0x6e0	; 0x6e0 <LCD_displayStringRowColumn>
	DelayTimer_8bits_synchrounous( _10_milli_sec, TIMER2_INDEX_ARRAY);
     cce:	8a e0       	ldi	r24, 0x0A	; 10
     cd0:	90 e0       	ldi	r25, 0x00	; 0
     cd2:	61 e0       	ldi	r22, 0x01	; 1
     cd4:	0e 94 0d 0b 	call	0x161a	; 0x161a <DelayTimer_8bits_synchrounous>

	LCD_moveCursor(1,0);
     cd8:	81 e0       	ldi	r24, 0x01	; 1
     cda:	60 e0       	ldi	r22, 0x00	; 0
     cdc:	0e 94 2e 03 	call	0x65c	; 0x65c <LCD_moveCursor>
     ce0:	20 c0       	rjmp	.+64     	; 0xd22 <Enter_Password_MainPage+0x7a>


	while(passCount < 5){

	  if(KEYPAD_getPressedKey()){
     ce2:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <KEYPAD_getPressedKey>
     ce6:	88 23       	and	r24, r24
     ce8:	e1 f0       	breq	.+56     	; 0xd22 <Enter_Password_MainPage+0x7a>

		checkPass[i] = KEYPAD_getPressedKey();
     cea:	80 91 3a 01 	lds	r24, 0x013A
     cee:	08 2f       	mov	r16, r24
     cf0:	10 e0       	ldi	r17, 0x00	; 0
     cf2:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <KEYPAD_getPressedKey>
     cf6:	f8 01       	movw	r30, r16
     cf8:	e2 5a       	subi	r30, 0xA2	; 162
     cfa:	fe 4f       	sbci	r31, 0xFE	; 254
     cfc:	80 83       	st	Z, r24
		LCD_displayCharacter('*');
     cfe:	8a e2       	ldi	r24, 0x2A	; 42
     d00:	0e 94 cf 02 	call	0x59e	; 0x59e <LCD_displayCharacter>
		DelayTimer_8bits_synchrounous( _500_milli_sec, TIMER2_INDEX_ARRAY);
     d04:	84 ef       	ldi	r24, 0xF4	; 244
     d06:	91 e0       	ldi	r25, 0x01	; 1
     d08:	61 e0       	ldi	r22, 0x01	; 1
     d0a:	0e 94 0d 0b 	call	0x161a	; 0x161a <DelayTimer_8bits_synchrounous>
		i++;
     d0e:	80 91 3a 01 	lds	r24, 0x013A
     d12:	8f 5f       	subi	r24, 0xFF	; 255
     d14:	80 93 3a 01 	sts	0x013A, r24
		passCount++;
     d18:	80 91 39 01 	lds	r24, 0x0139
     d1c:	8f 5f       	subi	r24, 0xFF	; 255
     d1e:	80 93 39 01 	sts	0x0139, r24
	DelayTimer_8bits_synchrounous( _10_milli_sec, TIMER2_INDEX_ARRAY);

	LCD_moveCursor(1,0);


	while(passCount < 5){
     d22:	80 91 39 01 	lds	r24, 0x0139
     d26:	85 30       	cpi	r24, 0x05	; 5
     d28:	e0 f2       	brcs	.-72     	; 0xce2 <Enter_Password_MainPage+0x3a>
	}

	   }


}
     d2a:	cf 91       	pop	r28
     d2c:	df 91       	pop	r29
     d2e:	1f 91       	pop	r17
     d30:	0f 91       	pop	r16
     d32:	08 95       	ret

00000d34 <Display_Warning_MainPage>:


 void Display_Warning_MainPage(void){
     d34:	df 93       	push	r29
     d36:	cf 93       	push	r28
     d38:	cd b7       	in	r28, 0x3d	; 61
     d3a:	de b7       	in	r29, 0x3e	; 62

	LCD_clearScreen();
     d3c:	0e 94 ac 03 	call	0x758	; 0x758 <LCD_clearScreen>
	LCD_displayStringRowColumn(1, 0, "Not Matching");
     d40:	2f e9       	ldi	r18, 0x9F	; 159
     d42:	30 e0       	ldi	r19, 0x00	; 0
     d44:	81 e0       	ldi	r24, 0x01	; 1
     d46:	60 e0       	ldi	r22, 0x00	; 0
     d48:	a9 01       	movw	r20, r18
     d4a:	0e 94 70 03 	call	0x6e0	; 0x6e0 <LCD_displayStringRowColumn>

	thief++;
     d4e:	80 91 3b 01 	lds	r24, 0x013B
     d52:	8f 5f       	subi	r24, 0xFF	; 255
     d54:	80 93 3b 01 	sts	0x013B, r24
	DelayTimer_8bits_synchrounous( _1000_milli_sec, TIMER2_INDEX_ARRAY);
     d58:	88 ee       	ldi	r24, 0xE8	; 232
     d5a:	93 e0       	ldi	r25, 0x03	; 3
     d5c:	61 e0       	ldi	r22, 0x01	; 1
     d5e:	0e 94 0d 0b 	call	0x161a	; 0x161a <DelayTimer_8bits_synchrounous>




}
     d62:	cf 91       	pop	r28
     d64:	df 91       	pop	r29
     d66:	08 95       	ret

00000d68 <Open_Door_MainPage>:


void Open_Door_MainPage(void){
     d68:	df 93       	push	r29
     d6a:	cf 93       	push	r28
     d6c:	cd b7       	in	r28, 0x3d	; 61
     d6e:	de b7       	in	r29, 0x3e	; 62

	if((0 == thief) || (1 == thief) || (2 == thief) ){
     d70:	80 91 3b 01 	lds	r24, 0x013B
     d74:	88 23       	and	r24, r24
     d76:	41 f0       	breq	.+16     	; 0xd88 <Open_Door_MainPage+0x20>
     d78:	80 91 3b 01 	lds	r24, 0x013B
     d7c:	81 30       	cpi	r24, 0x01	; 1
     d7e:	21 f0       	breq	.+8      	; 0xd88 <Open_Door_MainPage+0x20>
     d80:	80 91 3b 01 	lds	r24, 0x013B
     d84:	82 30       	cpi	r24, 0x02	; 2
     d86:	d9 f4       	brne	.+54     	; 0xdbe <Open_Door_MainPage+0x56>

	LCD_clearScreen();
     d88:	0e 94 ac 03 	call	0x758	; 0x758 <LCD_clearScreen>
	LCD_displayString("Correct Pass");
     d8c:	8c ea       	ldi	r24, 0xAC	; 172
     d8e:	90 e0       	ldi	r25, 0x00	; 0
     d90:	0e 94 05 03 	call	0x60a	; 0x60a <LCD_displayString>
	LCD_displayStringRowColumn(1, 0, "Open Door");
     d94:	29 eb       	ldi	r18, 0xB9	; 185
     d96:	30 e0       	ldi	r19, 0x00	; 0
     d98:	81 e0       	ldi	r24, 0x01	; 1
     d9a:	60 e0       	ldi	r22, 0x00	; 0
     d9c:	a9 01       	movw	r20, r18
     d9e:	0e 94 70 03 	call	0x6e0	; 0x6e0 <LCD_displayStringRowColumn>

	UART_SendByte('D'); /*send to MC2 signal to open door*/
     da2:	84 e4       	ldi	r24, 0x44	; 68
     da4:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <UART_SendByte>

	OverflowTimer_16bits_synchrounous( _8_sec );
     da8:	81 e0       	ldi	r24, 0x01	; 1
     daa:	0e 94 30 0d 	call	0x1a60	; 0x1a60 <OverflowTimer_16bits_synchrounous>

	 passCount = 0;
     dae:	10 92 39 01 	sts	0x0139, r1
	 i = 0;
     db2:	10 92 3a 01 	sts	0x013A, r1
	 thief =0;
     db6:	10 92 3b 01 	sts	0x013B, r1
	 gu8_option =0;
     dba:	10 92 38 01 	sts	0x0138, r1

	}


}
     dbe:	cf 91       	pop	r28
     dc0:	df 91       	pop	r29
     dc2:	08 95       	ret

00000dc4 <Activate_Buzzer>:

void Activate_Buzzer(void){
     dc4:	df 93       	push	r29
     dc6:	cf 93       	push	r28
     dc8:	cd b7       	in	r28, 0x3d	; 61
     dca:	de b7       	in	r29, 0x3e	; 62

	LCD_clearScreen(); /*clear screen*/
     dcc:	0e 94 ac 03 	call	0x758	; 0x758 <LCD_clearScreen>

	LCD_displayStringRowColumn(0, 0, "ERROR");
     dd0:	23 ec       	ldi	r18, 0xC3	; 195
     dd2:	30 e0       	ldi	r19, 0x00	; 0
     dd4:	80 e0       	ldi	r24, 0x00	; 0
     dd6:	60 e0       	ldi	r22, 0x00	; 0
     dd8:	a9 01       	movw	r20, r18
     dda:	0e 94 70 03 	call	0x6e0	; 0x6e0 <LCD_displayStringRowColumn>
	LCD_displayStringRowColumn(1, 0, "Buzzer On");
     dde:	29 ec       	ldi	r18, 0xC9	; 201
     de0:	30 e0       	ldi	r19, 0x00	; 0
     de2:	81 e0       	ldi	r24, 0x01	; 1
     de4:	60 e0       	ldi	r22, 0x00	; 0
     de6:	a9 01       	movw	r20, r18
     de8:	0e 94 70 03 	call	0x6e0	; 0x6e0 <LCD_displayStringRowColumn>

	OverflowTimer_16bits_synchrounous( _1_minute );  // wait 1 minute until the buzzer stops
     dec:	87 e0       	ldi	r24, 0x07	; 7
     dee:	0e 94 30 0d 	call	0x1a60	; 0x1a60 <OverflowTimer_16bits_synchrounous>

	LCD_clearScreen(); /*clear screen*/
     df2:	0e 94 ac 03 	call	0x758	; 0x758 <LCD_clearScreen>

	 passCount = 0;
     df6:	10 92 39 01 	sts	0x0139, r1
	 i = 0;
     dfa:	10 92 3a 01 	sts	0x013A, r1
	 thief =0;
     dfe:	10 92 3b 01 	sts	0x013B, r1
	 gu8_option =0;
     e02:	10 92 38 01 	sts	0x0138, r1



}
     e06:	cf 91       	pop	r28
     e08:	df 91       	pop	r29
     e0a:	08 95       	ret

00000e0c <Store_EEPROM_Password>:

void Store_EEPROM_Password(void){
     e0c:	0f 93       	push	r16
     e0e:	1f 93       	push	r17
     e10:	df 93       	push	r29
     e12:	cf 93       	push	r28
     e14:	cd b7       	in	r28, 0x3d	; 61
     e16:	de b7       	in	r29, 0x3e	; 62

	UART_SendByte('C'); /*tell MC2 to send the saved password*/
     e18:	83 e4       	ldi	r24, 0x43	; 67
     e1a:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <UART_SendByte>

	for(i = 0; i < 5; i++){
     e1e:	10 92 3a 01 	sts	0x013A, r1
     e22:	0f c0       	rjmp	.+30     	; 0xe42 <Store_EEPROM_Password+0x36>
		(storedPassEEPROM[i] = UART_ByteRecieved());
     e24:	80 91 3a 01 	lds	r24, 0x013A
     e28:	08 2f       	mov	r16, r24
     e2a:	10 e0       	ldi	r17, 0x00	; 0
     e2c:	0e 94 cc 00 	call	0x198	; 0x198 <UART_ByteRecieved>
     e30:	f8 01       	movw	r30, r16
     e32:	e7 59       	subi	r30, 0x97	; 151
     e34:	fe 4f       	sbci	r31, 0xFE	; 254
     e36:	80 83       	st	Z, r24

void Store_EEPROM_Password(void){

	UART_SendByte('C'); /*tell MC2 to send the saved password*/

	for(i = 0; i < 5; i++){
     e38:	80 91 3a 01 	lds	r24, 0x013A
     e3c:	8f 5f       	subi	r24, 0xFF	; 255
     e3e:	80 93 3a 01 	sts	0x013A, r24
     e42:	80 91 3a 01 	lds	r24, 0x013A
     e46:	85 30       	cpi	r24, 0x05	; 5
     e48:	68 f3       	brcs	.-38     	; 0xe24 <Store_EEPROM_Password+0x18>
		(storedPassEEPROM[i] = UART_ByteRecieved());

	}

}
     e4a:	cf 91       	pop	r28
     e4c:	df 91       	pop	r29
     e4e:	1f 91       	pop	r17
     e50:	0f 91       	pop	r16
     e52:	08 95       	ret

00000e54 <Check_Entered_Password>:

void Check_Entered_Password(void){
     e54:	df 93       	push	r29
     e56:	cf 93       	push	r28
     e58:	cd b7       	in	r28, 0x3d	; 61
     e5a:	de b7       	in	r29, 0x3e	; 62

	   for(Num_pass_Entered_Wrong=0 ; Num_pass_Entered_Wrong<4;Num_pass_Entered_Wrong++){
     e5c:	10 92 63 01 	sts	0x0163, r1
     e60:	35 c0       	rjmp	.+106    	; 0xecc <Check_Entered_Password+0x78>

			for(i = 0; i < 5; i++){ /* loop over number of characters  */
     e62:	10 92 3a 01 	sts	0x013A, r1
     e66:	1a c0       	rjmp	.+52     	; 0xe9c <Check_Entered_Password+0x48>

			if(checkPass[i] != storedPassEEPROM[i]){
     e68:	80 91 3a 01 	lds	r24, 0x013A
     e6c:	88 2f       	mov	r24, r24
     e6e:	90 e0       	ldi	r25, 0x00	; 0
     e70:	fc 01       	movw	r30, r24
     e72:	e2 5a       	subi	r30, 0xA2	; 162
     e74:	fe 4f       	sbci	r31, 0xFE	; 254
     e76:	20 81       	ld	r18, Z
     e78:	80 91 3a 01 	lds	r24, 0x013A
     e7c:	88 2f       	mov	r24, r24
     e7e:	90 e0       	ldi	r25, 0x00	; 0
     e80:	fc 01       	movw	r30, r24
     e82:	e7 59       	subi	r30, 0x97	; 151
     e84:	fe 4f       	sbci	r31, 0xFE	; 254
     e86:	80 81       	ld	r24, Z
     e88:	28 17       	cp	r18, r24
     e8a:	19 f0       	breq	.+6      	; 0xe92 <Check_Entered_Password+0x3e>
					Display_Warning_MainPage();
     e8c:	0e 94 9a 06 	call	0xd34	; 0xd34 <Display_Warning_MainPage>
     e90:	09 c0       	rjmp	.+18     	; 0xea4 <Check_Entered_Password+0x50>

void Check_Entered_Password(void){

	   for(Num_pass_Entered_Wrong=0 ; Num_pass_Entered_Wrong<4;Num_pass_Entered_Wrong++){

			for(i = 0; i < 5; i++){ /* loop over number of characters  */
     e92:	80 91 3a 01 	lds	r24, 0x013A
     e96:	8f 5f       	subi	r24, 0xFF	; 255
     e98:	80 93 3a 01 	sts	0x013A, r24
     e9c:	80 91 3a 01 	lds	r24, 0x013A
     ea0:	85 30       	cpi	r24, 0x05	; 5
     ea2:	10 f3       	brcs	.-60     	; 0xe68 <Check_Entered_Password+0x14>
					break; /*break from the for loop and go to the if condition ( 3 == thief)*/
				}/********************** End of if ************************/


			}/********************** End of for loop  --> for(i = 0; i < 5; i++) ************************/
			if ( 3 == thief){
     ea4:	80 91 3b 01 	lds	r24, 0x013B
     ea8:	83 30       	cpi	r24, 0x03	; 3
     eaa:	29 f4       	brne	.+10     	; 0xeb6 <Check_Entered_Password+0x62>
				    UART_SendByte('B');/*send signal to MC2 to activate buzzer*/
     eac:	82 e4       	ldi	r24, 0x42	; 66
     eae:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <UART_SendByte>
					Activate_Buzzer();
     eb2:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <Activate_Buzzer>

					}
			if( 4 == i ){
     eb6:	80 91 3a 01 	lds	r24, 0x013A
     eba:	84 30       	cpi	r24, 0x04	; 4
     ebc:	59 f0       	breq	.+22     	; 0xed4 <Check_Entered_Password+0x80>
				return; /* get out from the function if password is entered correctly*/
			}

			Enter_Password_MainPage();
     ebe:	0e 94 54 06 	call	0xca8	; 0xca8 <Enter_Password_MainPage>

}

void Check_Entered_Password(void){

	   for(Num_pass_Entered_Wrong=0 ; Num_pass_Entered_Wrong<4;Num_pass_Entered_Wrong++){
     ec2:	80 91 63 01 	lds	r24, 0x0163
     ec6:	8f 5f       	subi	r24, 0xFF	; 255
     ec8:	80 93 63 01 	sts	0x0163, r24
     ecc:	80 91 63 01 	lds	r24, 0x0163
     ed0:	84 30       	cpi	r24, 0x04	; 4
     ed2:	38 f2       	brcs	.-114    	; 0xe62 <Check_Entered_Password+0xe>

		}/********************** End of for loop ************************/



}
     ed4:	cf 91       	pop	r28
     ed6:	df 91       	pop	r29
     ed8:	08 95       	ret

00000eda <Store_Password_Again>:


 void static Store_Password_Again(void){
     eda:	0f 93       	push	r16
     edc:	1f 93       	push	r17
     ede:	df 93       	push	r29
     ee0:	cf 93       	push	r28
     ee2:	cd b7       	in	r28, 0x3d	; 61
     ee4:	de b7       	in	r29, 0x3e	; 62

	i=0;
     ee6:	10 92 3a 01 	sts	0x013A, r1
	passCount=0;
     eea:	10 92 39 01 	sts	0x0139, r1


	LCD_clearScreen(); /*clear screen*/
     eee:	0e 94 ac 03 	call	0x758	; 0x758 <LCD_clearScreen>
	LCD_displayStringRowColumn(0, 0, "RE-Enter pass:");
     ef2:	23 ed       	ldi	r18, 0xD3	; 211
     ef4:	30 e0       	ldi	r19, 0x00	; 0
     ef6:	80 e0       	ldi	r24, 0x00	; 0
     ef8:	60 e0       	ldi	r22, 0x00	; 0
     efa:	a9 01       	movw	r20, r18
     efc:	0e 94 70 03 	call	0x6e0	; 0x6e0 <LCD_displayStringRowColumn>
	LCD_moveCursor(1,0);
     f00:	81 e0       	ldi	r24, 0x01	; 1
     f02:	60 e0       	ldi	r22, 0x00	; 0
     f04:	0e 94 2e 03 	call	0x65c	; 0x65c <LCD_moveCursor>
     f08:	20 c0       	rjmp	.+64     	; 0xf4a <Store_Password_Again+0x70>


	while(passCount < 5){
	if(KEYPAD_getPressedKey()){
     f0a:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <KEYPAD_getPressedKey>
     f0e:	88 23       	and	r24, r24
     f10:	e1 f0       	breq	.+56     	; 0xf4a <Store_Password_Again+0x70>
	checkPass_Changed[i] = KEYPAD_getPressedKey();
     f12:	80 91 3a 01 	lds	r24, 0x013A
     f16:	08 2f       	mov	r16, r24
     f18:	10 e0       	ldi	r17, 0x00	; 0
     f1a:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <KEYPAD_getPressedKey>
     f1e:	f8 01       	movw	r30, r16
     f20:	ec 59       	subi	r30, 0x9C	; 156
     f22:	fe 4f       	sbci	r31, 0xFE	; 254
     f24:	80 83       	st	Z, r24
	LCD_displayCharacter('*');
     f26:	8a e2       	ldi	r24, 0x2A	; 42
     f28:	0e 94 cf 02 	call	0x59e	; 0x59e <LCD_displayCharacter>
	DelayTimer_8bits_synchrounous( _500_milli_sec, TIMER2_INDEX_ARRAY);
     f2c:	84 ef       	ldi	r24, 0xF4	; 244
     f2e:	91 e0       	ldi	r25, 0x01	; 1
     f30:	61 e0       	ldi	r22, 0x01	; 1
     f32:	0e 94 0d 0b 	call	0x161a	; 0x161a <DelayTimer_8bits_synchrounous>

	i++;
     f36:	80 91 3a 01 	lds	r24, 0x013A
     f3a:	8f 5f       	subi	r24, 0xFF	; 255
     f3c:	80 93 3a 01 	sts	0x013A, r24
	passCount++;
     f40:	80 91 39 01 	lds	r24, 0x0139
     f44:	8f 5f       	subi	r24, 0xFF	; 255
     f46:	80 93 39 01 	sts	0x0139, r24
	LCD_clearScreen(); /*clear screen*/
	LCD_displayStringRowColumn(0, 0, "RE-Enter pass:");
	LCD_moveCursor(1,0);


	while(passCount < 5){
     f4a:	80 91 39 01 	lds	r24, 0x0139
     f4e:	85 30       	cpi	r24, 0x05	; 5
     f50:	e0 f2       	brcs	.-72     	; 0xf0a <Store_Password_Again+0x30>
	i++;
	passCount++;
	  }
		}

 }
     f52:	cf 91       	pop	r28
     f54:	df 91       	pop	r29
     f56:	1f 91       	pop	r17
     f58:	0f 91       	pop	r16
     f5a:	08 95       	ret

00000f5c <Change_Password>:


 void Change_Password(void){
     f5c:	df 93       	push	r29
     f5e:	cf 93       	push	r28
     f60:	cd b7       	in	r28, 0x3d	; 61
     f62:	de b7       	in	r29, 0x3e	; 62

	  if((0 == thief) || (1 == thief) || (2 == thief) ){
     f64:	80 91 3b 01 	lds	r24, 0x013B
     f68:	88 23       	and	r24, r24
     f6a:	49 f0       	breq	.+18     	; 0xf7e <Change_Password+0x22>
     f6c:	80 91 3b 01 	lds	r24, 0x013B
     f70:	81 30       	cpi	r24, 0x01	; 1
     f72:	29 f0       	breq	.+10     	; 0xf7e <Change_Password+0x22>
     f74:	80 91 3b 01 	lds	r24, 0x013B
     f78:	82 30       	cpi	r24, 0x02	; 2
     f7a:	09 f0       	breq	.+2      	; 0xf7e <Change_Password+0x22>
     f7c:	3e c0       	rjmp	.+124    	; 0xffa <Change_Password+0x9e>

		  LCD_clearScreen();
     f7e:	0e 94 ac 03 	call	0x758	; 0x758 <LCD_clearScreen>
		  LCD_displayStringRowColumn(0, 0, "Enter new");
     f82:	22 ee       	ldi	r18, 0xE2	; 226
     f84:	30 e0       	ldi	r19, 0x00	; 0
     f86:	80 e0       	ldi	r24, 0x00	; 0
     f88:	60 e0       	ldi	r22, 0x00	; 0
     f8a:	a9 01       	movw	r20, r18
     f8c:	0e 94 70 03 	call	0x6e0	; 0x6e0 <LCD_displayStringRowColumn>
		  LCD_displayStringRowColumn(1, 0, "Password");
     f90:	2c ee       	ldi	r18, 0xEC	; 236
     f92:	30 e0       	ldi	r19, 0x00	; 0
     f94:	81 e0       	ldi	r24, 0x01	; 1
     f96:	60 e0       	ldi	r22, 0x00	; 0
     f98:	a9 01       	movw	r20, r18
     f9a:	0e 94 70 03 	call	0x6e0	; 0x6e0 <LCD_displayStringRowColumn>
		  DelayTimer_8bits_synchrounous( _1000_milli_sec, TIMER2_INDEX_ARRAY);
     f9e:	88 ee       	ldi	r24, 0xE8	; 232
     fa0:	93 e0       	ldi	r25, 0x03	; 3
     fa2:	61 e0       	ldi	r22, 0x01	; 1
     fa4:	0e 94 0d 0b 	call	0x161a	; 0x161a <DelayTimer_8bits_synchrounous>

		  Enter_Password_MainPage(); //first time password entered will be stored in checkPass[]
     fa8:	0e 94 54 06 	call	0xca8	; 0xca8 <Enter_Password_MainPage>

		  Store_Password_Again();
     fac:	0e 94 6d 07 	call	0xeda	; 0xeda <Store_Password_Again>
     fb0:	12 c0       	rjmp	.+36     	; 0xfd6 <Change_Password+0x7a>


		  while(checkPass_Changed[i] !=  checkPass[i]){

				LCD_clearScreen(); /*clear screen*/
     fb2:	0e 94 ac 03 	call	0x758	; 0x758 <LCD_clearScreen>
				LCD_displayStringRowColumn(0, 0, "Not Matching");
     fb6:	2f e9       	ldi	r18, 0x9F	; 159
     fb8:	30 e0       	ldi	r19, 0x00	; 0
     fba:	80 e0       	ldi	r24, 0x00	; 0
     fbc:	60 e0       	ldi	r22, 0x00	; 0
     fbe:	a9 01       	movw	r20, r18
     fc0:	0e 94 70 03 	call	0x6e0	; 0x6e0 <LCD_displayStringRowColumn>
				DelayTimer_8bits_synchrounous( _500_milli_sec, TIMER2_INDEX_ARRAY);
     fc4:	84 ef       	ldi	r24, 0xF4	; 244
     fc6:	91 e0       	ldi	r25, 0x01	; 1
     fc8:	61 e0       	ldi	r22, 0x01	; 1
     fca:	0e 94 0d 0b 	call	0x161a	; 0x161a <DelayTimer_8bits_synchrounous>

				Enter_Password_MainPage();
     fce:	0e 94 54 06 	call	0xca8	; 0xca8 <Enter_Password_MainPage>
				Store_Password_Again();
     fd2:	0e 94 6d 07 	call	0xeda	; 0xeda <Store_Password_Again>
		  Enter_Password_MainPage(); //first time password entered will be stored in checkPass[]

		  Store_Password_Again();


		  while(checkPass_Changed[i] !=  checkPass[i]){
     fd6:	80 91 3a 01 	lds	r24, 0x013A
     fda:	88 2f       	mov	r24, r24
     fdc:	90 e0       	ldi	r25, 0x00	; 0
     fde:	fc 01       	movw	r30, r24
     fe0:	ec 59       	subi	r30, 0x9C	; 156
     fe2:	fe 4f       	sbci	r31, 0xFE	; 254
     fe4:	20 81       	ld	r18, Z
     fe6:	80 91 3a 01 	lds	r24, 0x013A
     fea:	88 2f       	mov	r24, r24
     fec:	90 e0       	ldi	r25, 0x00	; 0
     fee:	fc 01       	movw	r30, r24
     ff0:	e2 5a       	subi	r30, 0xA2	; 162
     ff2:	fe 4f       	sbci	r31, 0xFE	; 254
     ff4:	80 81       	ld	r24, Z
     ff6:	28 17       	cp	r18, r24
     ff8:	e1 f6       	brne	.-72     	; 0xfb2 <Change_Password+0x56>

			}

	  }

  }
     ffa:	cf 91       	pop	r28
     ffc:	df 91       	pop	r29
     ffe:	08 95       	ret

00001000 <Send_Password_MC2>:


 void Send_Password_MC2(void){
    1000:	df 93       	push	r29
    1002:	cf 93       	push	r28
    1004:	cd b7       	in	r28, 0x3d	; 61
    1006:	de b7       	in	r29, 0x3e	; 62

	 UART_SendByte('A'); /*send a signal to MC2 to save the next sent data*/
    1008:	81 e4       	ldi	r24, 0x41	; 65
    100a:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <UART_SendByte>

		/*Send the password to MC2 to save it to EEPROM*/
		for(i = 0; i < 5; i++){
    100e:	10 92 3a 01 	sts	0x013A, r1
    1012:	0f c0       	rjmp	.+30     	; 0x1032 <Send_Password_MC2+0x32>

			UART_SendByte(checkPass_Changed[i]); /*send password to MC2 to save it in EEPROM*/
    1014:	80 91 3a 01 	lds	r24, 0x013A
    1018:	88 2f       	mov	r24, r24
    101a:	90 e0       	ldi	r25, 0x00	; 0
    101c:	fc 01       	movw	r30, r24
    101e:	ec 59       	subi	r30, 0x9C	; 156
    1020:	fe 4f       	sbci	r31, 0xFE	; 254
    1022:	80 81       	ld	r24, Z
    1024:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <UART_SendByte>
 void Send_Password_MC2(void){

	 UART_SendByte('A'); /*send a signal to MC2 to save the next sent data*/

		/*Send the password to MC2 to save it to EEPROM*/
		for(i = 0; i < 5; i++){
    1028:	80 91 3a 01 	lds	r24, 0x013A
    102c:	8f 5f       	subi	r24, 0xFF	; 255
    102e:	80 93 3a 01 	sts	0x013A, r24
    1032:	80 91 3a 01 	lds	r24, 0x013A
    1036:	85 30       	cpi	r24, 0x05	; 5
    1038:	68 f3       	brcs	.-38     	; 0x1014 <Send_Password_MC2+0x14>

			UART_SendByte(checkPass_Changed[i]); /*send password to MC2 to save it in EEPROM*/
		}

		LCD_clearScreen();
    103a:	0e 94 ac 03 	call	0x758	; 0x758 <LCD_clearScreen>
		LCD_displayStringRowColumn(0,0,"Saved");
    103e:	25 ef       	ldi	r18, 0xF5	; 245
    1040:	30 e0       	ldi	r19, 0x00	; 0
    1042:	80 e0       	ldi	r24, 0x00	; 0
    1044:	60 e0       	ldi	r22, 0x00	; 0
    1046:	a9 01       	movw	r20, r18
    1048:	0e 94 70 03 	call	0x6e0	; 0x6e0 <LCD_displayStringRowColumn>
		DelayTimer_8bits_synchrounous( _1000_milli_sec, TIMER2_INDEX_ARRAY);
    104c:	88 ee       	ldi	r24, 0xE8	; 232
    104e:	93 e0       	ldi	r25, 0x03	; 3
    1050:	61 e0       	ldi	r22, 0x01	; 1
    1052:	0e 94 0d 0b 	call	0x161a	; 0x161a <DelayTimer_8bits_synchrounous>


 }
    1056:	cf 91       	pop	r28
    1058:	df 91       	pop	r29
    105a:	08 95       	ret

0000105c <__vector_9>:


/********************************************  ISR  ***************************************************************************/

/************************** ID =3.5 ******************************/
ISR(TIMER0_OVF_vect){
    105c:	1f 92       	push	r1
    105e:	0f 92       	push	r0
    1060:	0f b6       	in	r0, 0x3f	; 63
    1062:	0f 92       	push	r0
    1064:	11 24       	eor	r1, r1
    1066:	2f 93       	push	r18
    1068:	3f 93       	push	r19
    106a:	4f 93       	push	r20
    106c:	5f 93       	push	r21
    106e:	6f 93       	push	r22
    1070:	7f 93       	push	r23
    1072:	8f 93       	push	r24
    1074:	9f 93       	push	r25
    1076:	af 93       	push	r26
    1078:	bf 93       	push	r27
    107a:	ef 93       	push	r30
    107c:	ff 93       	push	r31
    107e:	df 93       	push	r29
    1080:	cf 93       	push	r28
    1082:	00 d0       	rcall	.+0      	; 0x1084 <__vector_9+0x28>
    1084:	cd b7       	in	r28, 0x3d	; 61
    1086:	de b7       	in	r29, 0x3e	; 62
	  	if(func_register_8bit_overflow[TIMER0_OVF] != NULL_PTR){
    1088:	80 91 46 01 	lds	r24, 0x0146
    108c:	90 91 47 01 	lds	r25, 0x0147
    1090:	00 97       	sbiw	r24, 0x00	; 0
    1092:	f9 f0       	breq	.+62     	; 0x10d2 <__vector_9+0x76>

	  		/*Checking of the delay time expired or not*/
	  		if(gu8_delayTime[TIMER0_INDEX_ARRAY]--){
    1094:	80 91 3f 01 	lds	r24, 0x013F
    1098:	89 83       	std	Y+1, r24	; 0x01
    109a:	89 81       	ldd	r24, Y+1	; 0x01
    109c:	8a 83       	std	Y+2, r24	; 0x02
    109e:	8a 81       	ldd	r24, Y+2	; 0x02
    10a0:	88 23       	and	r24, r24
    10a2:	11 f0       	breq	.+4      	; 0x10a8 <__vector_9+0x4c>
    10a4:	81 e0       	ldi	r24, 0x01	; 1
    10a6:	8a 83       	std	Y+2, r24	; 0x02
    10a8:	9a 81       	ldd	r25, Y+2	; 0x02
    10aa:	89 81       	ldd	r24, Y+1	; 0x01
    10ac:	81 50       	subi	r24, 0x01	; 1
    10ae:	80 93 3f 01 	sts	0x013F, r24
    10b2:	81 e0       	ldi	r24, 0x01	; 1
    10b4:	89 27       	eor	r24, r25
    10b6:	88 23       	and	r24, r24
    10b8:	61 f0       	breq	.+24     	; 0x10d2 <__vector_9+0x76>
	  			/*Do nothing */
	  		}

	  		else{

	  			mtimer_8bits_stop(TIMER0_INDEX_ARRAY);
    10ba:	80 e0       	ldi	r24, 0x00	; 0
    10bc:	0e 94 7e 08 	call	0x10fc	; 0x10fc <mtimer_8bits_stop>
	  			OverflowTimer_timer0_Asynchrounous_is_Running=0;
    10c0:	10 92 43 01 	sts	0x0143, r1
	  			gu8_delayTime[TIMER0_INDEX_ARRAY]=0;
    10c4:	10 92 3f 01 	sts	0x013F, r1

	  		   func_register_8bit_overflow[TIMER0_OVF]();
    10c8:	e0 91 46 01 	lds	r30, 0x0146
    10cc:	f0 91 47 01 	lds	r31, 0x0147
    10d0:	09 95       	icall


	  		}

	}
}
    10d2:	0f 90       	pop	r0
    10d4:	0f 90       	pop	r0
    10d6:	cf 91       	pop	r28
    10d8:	df 91       	pop	r29
    10da:	ff 91       	pop	r31
    10dc:	ef 91       	pop	r30
    10de:	bf 91       	pop	r27
    10e0:	af 91       	pop	r26
    10e2:	9f 91       	pop	r25
    10e4:	8f 91       	pop	r24
    10e6:	7f 91       	pop	r23
    10e8:	6f 91       	pop	r22
    10ea:	5f 91       	pop	r21
    10ec:	4f 91       	pop	r20
    10ee:	3f 91       	pop	r19
    10f0:	2f 91       	pop	r18
    10f2:	0f 90       	pop	r0
    10f4:	0f be       	out	0x3f, r0	; 63
    10f6:	0f 90       	pop	r0
    10f8:	1f 90       	pop	r1
    10fa:	18 95       	reti

000010fc <mtimer_8bits_stop>:

}

/************************** ID =3.2 ******************************/
void static inline mtimer_8bits_stop(u8_t timerIndex)
{
    10fc:	df 93       	push	r29
    10fe:	cf 93       	push	r28
    1100:	0f 92       	push	r0
    1102:	cd b7       	in	r28, 0x3d	; 61
    1104:	de b7       	in	r29, 0x3e	; 62
    1106:	89 83       	std	Y+1, r24	; 0x01
	/*Clear the bits responsible for the clock selection*/
	*Timer_8bits_Control_Register[timerIndex] &= ~(1<<TCCR_CLOCK_SELECT_0) & ~(1<<TCCR_CLOCK_SELECT_1) & ~(1<<TCCR_CLOCK_SELECT_2);
    1108:	89 81       	ldd	r24, Y+1	; 0x01
    110a:	88 2f       	mov	r24, r24
    110c:	90 e0       	ldi	r25, 0x00	; 0
    110e:	88 0f       	add	r24, r24
    1110:	99 1f       	adc	r25, r25
    1112:	fc 01       	movw	r30, r24
    1114:	e4 5d       	subi	r30, 0xD4	; 212
    1116:	fe 4f       	sbci	r31, 0xFE	; 254
    1118:	a0 81       	ld	r26, Z
    111a:	b1 81       	ldd	r27, Z+1	; 0x01
    111c:	89 81       	ldd	r24, Y+1	; 0x01
    111e:	88 2f       	mov	r24, r24
    1120:	90 e0       	ldi	r25, 0x00	; 0
    1122:	88 0f       	add	r24, r24
    1124:	99 1f       	adc	r25, r25
    1126:	fc 01       	movw	r30, r24
    1128:	e4 5d       	subi	r30, 0xD4	; 212
    112a:	fe 4f       	sbci	r31, 0xFE	; 254
    112c:	01 90       	ld	r0, Z+
    112e:	f0 81       	ld	r31, Z
    1130:	e0 2d       	mov	r30, r0
    1132:	80 81       	ld	r24, Z
    1134:	88 7f       	andi	r24, 0xF8	; 248
    1136:	8c 93       	st	X, r24

	/*Return from this function*/
	return;
}
    1138:	0f 90       	pop	r0
    113a:	cf 91       	pop	r28
    113c:	df 91       	pop	r29
    113e:	08 95       	ret

00001140 <__vector_4>:
	}
}
/****************************************************/

/************************** ID =3.6 ******************************/
ISR(TIMER2_OVF_vect){
    1140:	1f 92       	push	r1
    1142:	0f 92       	push	r0
    1144:	0f b6       	in	r0, 0x3f	; 63
    1146:	0f 92       	push	r0
    1148:	11 24       	eor	r1, r1
    114a:	2f 93       	push	r18
    114c:	3f 93       	push	r19
    114e:	4f 93       	push	r20
    1150:	5f 93       	push	r21
    1152:	6f 93       	push	r22
    1154:	7f 93       	push	r23
    1156:	8f 93       	push	r24
    1158:	9f 93       	push	r25
    115a:	af 93       	push	r26
    115c:	bf 93       	push	r27
    115e:	ef 93       	push	r30
    1160:	ff 93       	push	r31
    1162:	df 93       	push	r29
    1164:	cf 93       	push	r28
    1166:	00 d0       	rcall	.+0      	; 0x1168 <__vector_4+0x28>
    1168:	cd b7       	in	r28, 0x3d	; 61
    116a:	de b7       	in	r29, 0x3e	; 62
	if(func_register_8bit_overflow[TIMER2_OVF] != NULL_PTR){
    116c:	80 91 48 01 	lds	r24, 0x0148
    1170:	90 91 49 01 	lds	r25, 0x0149
    1174:	00 97       	sbiw	r24, 0x00	; 0
    1176:	f9 f0       	breq	.+62     	; 0x11b6 <__vector_4+0x76>

		/*Checking of the delay time expired or not*/
			  		if(gu8_delayTime[TIMER2_INDEX_ARRAY]--){
    1178:	80 91 40 01 	lds	r24, 0x0140
    117c:	89 83       	std	Y+1, r24	; 0x01
    117e:	89 81       	ldd	r24, Y+1	; 0x01
    1180:	8a 83       	std	Y+2, r24	; 0x02
    1182:	8a 81       	ldd	r24, Y+2	; 0x02
    1184:	88 23       	and	r24, r24
    1186:	11 f0       	breq	.+4      	; 0x118c <__vector_4+0x4c>
    1188:	81 e0       	ldi	r24, 0x01	; 1
    118a:	8a 83       	std	Y+2, r24	; 0x02
    118c:	9a 81       	ldd	r25, Y+2	; 0x02
    118e:	89 81       	ldd	r24, Y+1	; 0x01
    1190:	81 50       	subi	r24, 0x01	; 1
    1192:	80 93 40 01 	sts	0x0140, r24
    1196:	81 e0       	ldi	r24, 0x01	; 1
    1198:	89 27       	eor	r24, r25
    119a:	88 23       	and	r24, r24
    119c:	61 f0       	breq	.+24     	; 0x11b6 <__vector_4+0x76>
			  			/*Do nothing */
			  		}


	else{
		        mtimer_8bits_stop(TIMER2_INDEX_ARRAY);
    119e:	81 e0       	ldi	r24, 0x01	; 1
    11a0:	0e 94 7e 08 	call	0x10fc	; 0x10fc <mtimer_8bits_stop>
		        OverflowTimer_timer2_Asynchrounous_is_Running=0;
    11a4:	10 92 45 01 	sts	0x0145, r1
		        gu8_delayTime[TIMER2_INDEX_ARRAY]=0;
    11a8:	10 92 40 01 	sts	0x0140, r1

		  		func_register_8bit_overflow[TIMER2_OVF]();
    11ac:	e0 91 48 01 	lds	r30, 0x0148
    11b0:	f0 91 49 01 	lds	r31, 0x0149
    11b4:	09 95       	icall



		  		}
}
}
    11b6:	0f 90       	pop	r0
    11b8:	0f 90       	pop	r0
    11ba:	cf 91       	pop	r28
    11bc:	df 91       	pop	r29
    11be:	ff 91       	pop	r31
    11c0:	ef 91       	pop	r30
    11c2:	bf 91       	pop	r27
    11c4:	af 91       	pop	r26
    11c6:	9f 91       	pop	r25
    11c8:	8f 91       	pop	r24
    11ca:	7f 91       	pop	r23
    11cc:	6f 91       	pop	r22
    11ce:	5f 91       	pop	r21
    11d0:	4f 91       	pop	r20
    11d2:	3f 91       	pop	r19
    11d4:	2f 91       	pop	r18
    11d6:	0f 90       	pop	r0
    11d8:	0f be       	out	0x3f, r0	; 63
    11da:	0f 90       	pop	r0
    11dc:	1f 90       	pop	r1
    11de:	18 95       	reti

000011e0 <__vector_19>:
/****************************************************/
/****************************************************/
/****************************************************/

/************************** ID =3.7 ******************************/
ISR(TIMER0_COMP_vect){
    11e0:	1f 92       	push	r1
    11e2:	0f 92       	push	r0
    11e4:	0f b6       	in	r0, 0x3f	; 63
    11e6:	0f 92       	push	r0
    11e8:	11 24       	eor	r1, r1
    11ea:	2f 93       	push	r18
    11ec:	3f 93       	push	r19
    11ee:	4f 93       	push	r20
    11f0:	5f 93       	push	r21
    11f2:	6f 93       	push	r22
    11f4:	7f 93       	push	r23
    11f6:	8f 93       	push	r24
    11f8:	9f 93       	push	r25
    11fa:	af 93       	push	r26
    11fc:	bf 93       	push	r27
    11fe:	ef 93       	push	r30
    1200:	ff 93       	push	r31
    1202:	df 93       	push	r29
    1204:	cf 93       	push	r28
    1206:	00 d0       	rcall	.+0      	; 0x1208 <__vector_19+0x28>
    1208:	cd b7       	in	r28, 0x3d	; 61
    120a:	de b7       	in	r29, 0x3e	; 62
	if(func_register_8bit_compare[TIMER0_COMP] != NULL_PTR){
    120c:	80 91 4a 01 	lds	r24, 0x014A
    1210:	90 91 4b 01 	lds	r25, 0x014B
    1214:	00 97       	sbiw	r24, 0x00	; 0
    1216:	f9 f0       	breq	.+62     	; 0x1256 <__vector_19+0x76>

				/*Checking of the delay time expired or not*/
				  		if(gu8_delayTime[TIMER0_INDEX_ARRAY]--){
    1218:	80 91 3f 01 	lds	r24, 0x013F
    121c:	89 83       	std	Y+1, r24	; 0x01
    121e:	89 81       	ldd	r24, Y+1	; 0x01
    1220:	8a 83       	std	Y+2, r24	; 0x02
    1222:	8a 81       	ldd	r24, Y+2	; 0x02
    1224:	88 23       	and	r24, r24
    1226:	11 f0       	breq	.+4      	; 0x122c <__vector_19+0x4c>
    1228:	81 e0       	ldi	r24, 0x01	; 1
    122a:	8a 83       	std	Y+2, r24	; 0x02
    122c:	9a 81       	ldd	r25, Y+2	; 0x02
    122e:	89 81       	ldd	r24, Y+1	; 0x01
    1230:	81 50       	subi	r24, 0x01	; 1
    1232:	80 93 3f 01 	sts	0x013F, r24
    1236:	81 e0       	ldi	r24, 0x01	; 1
    1238:	89 27       	eor	r24, r25
    123a:	88 23       	and	r24, r24
    123c:	61 f0       	breq	.+24     	; 0x1256 <__vector_19+0x76>
				  			/*Do nothing */
				  		}

		else{

			gu8_delayTime[TIMER0_INDEX_ARRAY]=0;
    123e:	10 92 3f 01 	sts	0x013F, r1
			mtimer_8bits_stop(TIMER0_INDEX_ARRAY);
    1242:	80 e0       	ldi	r24, 0x00	; 0
    1244:	0e 94 7e 08 	call	0x10fc	; 0x10fc <mtimer_8bits_stop>
			DelayTimer_timer0_Asynchrounous_is_Running= 0;
    1248:	10 92 42 01 	sts	0x0142, r1


		   func_register_8bit_compare[TIMER0_COMP]();
    124c:	e0 91 4a 01 	lds	r30, 0x014A
    1250:	f0 91 4b 01 	lds	r31, 0x014B
    1254:	09 95       	icall

	}


  }
}
    1256:	0f 90       	pop	r0
    1258:	0f 90       	pop	r0
    125a:	cf 91       	pop	r28
    125c:	df 91       	pop	r29
    125e:	ff 91       	pop	r31
    1260:	ef 91       	pop	r30
    1262:	bf 91       	pop	r27
    1264:	af 91       	pop	r26
    1266:	9f 91       	pop	r25
    1268:	8f 91       	pop	r24
    126a:	7f 91       	pop	r23
    126c:	6f 91       	pop	r22
    126e:	5f 91       	pop	r21
    1270:	4f 91       	pop	r20
    1272:	3f 91       	pop	r19
    1274:	2f 91       	pop	r18
    1276:	0f 90       	pop	r0
    1278:	0f be       	out	0x3f, r0	; 63
    127a:	0f 90       	pop	r0
    127c:	1f 90       	pop	r1
    127e:	18 95       	reti

00001280 <__vector_3>:
/****************************************************/

/************************** ID =3.8 ******************************/
ISR(TIMER2_COMP_vect){
    1280:	1f 92       	push	r1
    1282:	0f 92       	push	r0
    1284:	0f b6       	in	r0, 0x3f	; 63
    1286:	0f 92       	push	r0
    1288:	11 24       	eor	r1, r1
    128a:	2f 93       	push	r18
    128c:	3f 93       	push	r19
    128e:	4f 93       	push	r20
    1290:	5f 93       	push	r21
    1292:	6f 93       	push	r22
    1294:	7f 93       	push	r23
    1296:	8f 93       	push	r24
    1298:	9f 93       	push	r25
    129a:	af 93       	push	r26
    129c:	bf 93       	push	r27
    129e:	ef 93       	push	r30
    12a0:	ff 93       	push	r31
    12a2:	df 93       	push	r29
    12a4:	cf 93       	push	r28
    12a6:	00 d0       	rcall	.+0      	; 0x12a8 <__vector_3+0x28>
    12a8:	cd b7       	in	r28, 0x3d	; 61
    12aa:	de b7       	in	r29, 0x3e	; 62
 	if(func_register_8bit_compare[TIMER2_COMP] != NULL_PTR){
    12ac:	80 91 4c 01 	lds	r24, 0x014C
    12b0:	90 91 4d 01 	lds	r25, 0x014D
    12b4:	00 97       	sbiw	r24, 0x00	; 0
    12b6:	f9 f0       	breq	.+62     	; 0x12f6 <__vector_3+0x76>

 		/*Checking of the delay time expired or not*/
 						  		if(gu8_delayTime[TIMER2_INDEX_ARRAY]--){
    12b8:	80 91 40 01 	lds	r24, 0x0140
    12bc:	89 83       	std	Y+1, r24	; 0x01
    12be:	89 81       	ldd	r24, Y+1	; 0x01
    12c0:	8a 83       	std	Y+2, r24	; 0x02
    12c2:	8a 81       	ldd	r24, Y+2	; 0x02
    12c4:	88 23       	and	r24, r24
    12c6:	11 f0       	breq	.+4      	; 0x12cc <__vector_3+0x4c>
    12c8:	81 e0       	ldi	r24, 0x01	; 1
    12ca:	8a 83       	std	Y+2, r24	; 0x02
    12cc:	9a 81       	ldd	r25, Y+2	; 0x02
    12ce:	89 81       	ldd	r24, Y+1	; 0x01
    12d0:	81 50       	subi	r24, 0x01	; 1
    12d2:	80 93 40 01 	sts	0x0140, r24
    12d6:	81 e0       	ldi	r24, 0x01	; 1
    12d8:	89 27       	eor	r24, r25
    12da:	88 23       	and	r24, r24
    12dc:	61 f0       	breq	.+24     	; 0x12f6 <__vector_3+0x76>
 						  			/*Do nothing */
 						  		}

 			else{

 		 		gu8_delayTime[TIMER2_INDEX_ARRAY]=0;
    12de:	10 92 40 01 	sts	0x0140, r1
 		 		mtimer_8bits_stop(TIMER2_INDEX_ARRAY);
    12e2:	81 e0       	ldi	r24, 0x01	; 1
    12e4:	0e 94 7e 08 	call	0x10fc	; 0x10fc <mtimer_8bits_stop>
 		 		DelayTimer_timer2_Asynchrounous_is_Running= 0;
    12e8:	10 92 44 01 	sts	0x0144, r1


 		        func_register_8bit_compare[TIMER2_COMP]();
    12ec:	e0 91 4c 01 	lds	r30, 0x014C
    12f0:	f0 91 4d 01 	lds	r31, 0x014D
    12f4:	09 95       	icall

 		}

 	}
 }
    12f6:	0f 90       	pop	r0
    12f8:	0f 90       	pop	r0
    12fa:	cf 91       	pop	r28
    12fc:	df 91       	pop	r29
    12fe:	ff 91       	pop	r31
    1300:	ef 91       	pop	r30
    1302:	bf 91       	pop	r27
    1304:	af 91       	pop	r26
    1306:	9f 91       	pop	r25
    1308:	8f 91       	pop	r24
    130a:	7f 91       	pop	r23
    130c:	6f 91       	pop	r22
    130e:	5f 91       	pop	r21
    1310:	4f 91       	pop	r20
    1312:	3f 91       	pop	r19
    1314:	2f 91       	pop	r18
    1316:	0f 90       	pop	r0
    1318:	0f be       	out	0x3f, r0	; 63
    131a:	0f 90       	pop	r0
    131c:	1f 90       	pop	r1
    131e:	18 95       	reti

00001320 <__vector_8>:
/****************************************************/
/****************************************************/
/****************************************************/
/************************** ID =3.9 ******************************/
ISR(TIMER1_OVF_vect){
    1320:	1f 92       	push	r1
    1322:	0f 92       	push	r0
    1324:	0f b6       	in	r0, 0x3f	; 63
    1326:	0f 92       	push	r0
    1328:	11 24       	eor	r1, r1
    132a:	2f 93       	push	r18
    132c:	3f 93       	push	r19
    132e:	4f 93       	push	r20
    1330:	5f 93       	push	r21
    1332:	6f 93       	push	r22
    1334:	7f 93       	push	r23
    1336:	8f 93       	push	r24
    1338:	9f 93       	push	r25
    133a:	af 93       	push	r26
    133c:	bf 93       	push	r27
    133e:	ef 93       	push	r30
    1340:	ff 93       	push	r31
    1342:	df 93       	push	r29
    1344:	cf 93       	push	r28
    1346:	00 d0       	rcall	.+0      	; 0x1348 <__vector_8+0x28>
    1348:	cd b7       	in	r28, 0x3d	; 61
    134a:	de b7       	in	r29, 0x3e	; 62
	if(func_register_16bit_timer1[TIMER1_OVF] != NULL_PTR){
    134c:	80 91 4e 01 	lds	r24, 0x014E
    1350:	90 91 4f 01 	lds	r25, 0x014F
    1354:	00 97       	sbiw	r24, 0x00	; 0
    1356:	d1 f0       	breq	.+52     	; 0x138c <__vector_8+0x6c>

		if (Number_OverFlows_16bit_Timer --){
    1358:	80 91 41 01 	lds	r24, 0x0141
    135c:	89 83       	std	Y+1, r24	; 0x01
    135e:	89 81       	ldd	r24, Y+1	; 0x01
    1360:	8a 83       	std	Y+2, r24	; 0x02
    1362:	8a 81       	ldd	r24, Y+2	; 0x02
    1364:	88 23       	and	r24, r24
    1366:	11 f0       	breq	.+4      	; 0x136c <__vector_8+0x4c>
    1368:	81 e0       	ldi	r24, 0x01	; 1
    136a:	8a 83       	std	Y+2, r24	; 0x02
    136c:	9a 81       	ldd	r25, Y+2	; 0x02
    136e:	89 81       	ldd	r24, Y+1	; 0x01
    1370:	81 50       	subi	r24, 0x01	; 1
    1372:	80 93 41 01 	sts	0x0141, r24
    1376:	81 e0       	ldi	r24, 0x01	; 1
    1378:	89 27       	eor	r24, r25
    137a:	88 23       	and	r24, r24
    137c:	39 f0       	breq	.+14     	; 0x138c <__vector_8+0x6c>
             /* Do nothing  */
		}

		else{
		func_register_16bit_timer1[TIMER1_OVF]();
    137e:	e0 91 4e 01 	lds	r30, 0x014E
    1382:	f0 91 4f 01 	lds	r31, 0x014F
    1386:	09 95       	icall

		mtimer_16bits_stop();
    1388:	0e 94 db 09 	call	0x13b6	; 0x13b6 <mtimer_16bits_stop>
		}

	}
}
    138c:	0f 90       	pop	r0
    138e:	0f 90       	pop	r0
    1390:	cf 91       	pop	r28
    1392:	df 91       	pop	r29
    1394:	ff 91       	pop	r31
    1396:	ef 91       	pop	r30
    1398:	bf 91       	pop	r27
    139a:	af 91       	pop	r26
    139c:	9f 91       	pop	r25
    139e:	8f 91       	pop	r24
    13a0:	7f 91       	pop	r23
    13a2:	6f 91       	pop	r22
    13a4:	5f 91       	pop	r21
    13a6:	4f 91       	pop	r20
    13a8:	3f 91       	pop	r19
    13aa:	2f 91       	pop	r18
    13ac:	0f 90       	pop	r0
    13ae:	0f be       	out	0x3f, r0	; 63
    13b0:	0f 90       	pop	r0
    13b2:	1f 90       	pop	r1
    13b4:	18 95       	reti

000013b6 <mtimer_16bits_stop>:
	MTIMER_TCCR1B |= gu8_timer_16bits_SelectedPrescaler1;

}

/************************** ID =3.4 ******************************/
void static inline mtimer_16bits_stop(void){
    13b6:	df 93       	push	r29
    13b8:	cf 93       	push	r28
    13ba:	cd b7       	in	r28, 0x3d	; 61
    13bc:	de b7       	in	r29, 0x3e	; 62
	MTIMER_TCCR1B &= ~(TCCR1B_CLOCK_SELECT_10) & ~(TCCR1B_CLOCK_SELECT_11) & ~(TCCR1B_CLOCK_SELECT_12);
    13be:	ae e4       	ldi	r26, 0x4E	; 78
    13c0:	b0 e0       	ldi	r27, 0x00	; 0
    13c2:	ee e4       	ldi	r30, 0x4E	; 78
    13c4:	f0 e0       	ldi	r31, 0x00	; 0
    13c6:	80 81       	ld	r24, Z
    13c8:	8c 7f       	andi	r24, 0xFC	; 252
    13ca:	8c 93       	st	X, r24

}
    13cc:	cf 91       	pop	r28
    13ce:	df 91       	pop	r29
    13d0:	08 95       	ret

000013d2 <__vector_6>:
	}
}
/****************************************************/

/************************** ID =3.10 ******************************/
ISR(TIMER1_COMPA_vect){
    13d2:	1f 92       	push	r1
    13d4:	0f 92       	push	r0
    13d6:	0f b6       	in	r0, 0x3f	; 63
    13d8:	0f 92       	push	r0
    13da:	11 24       	eor	r1, r1
    13dc:	2f 93       	push	r18
    13de:	3f 93       	push	r19
    13e0:	4f 93       	push	r20
    13e2:	5f 93       	push	r21
    13e4:	6f 93       	push	r22
    13e6:	7f 93       	push	r23
    13e8:	8f 93       	push	r24
    13ea:	9f 93       	push	r25
    13ec:	af 93       	push	r26
    13ee:	bf 93       	push	r27
    13f0:	ef 93       	push	r30
    13f2:	ff 93       	push	r31
    13f4:	df 93       	push	r29
    13f6:	cf 93       	push	r28
    13f8:	00 d0       	rcall	.+0      	; 0x13fa <__vector_6+0x28>
    13fa:	cd b7       	in	r28, 0x3d	; 61
    13fc:	de b7       	in	r29, 0x3e	; 62
	if(func_register_16bit_timer1[TIMER1_COMPA] != NULL_PTR){
    13fe:	80 91 50 01 	lds	r24, 0x0150
    1402:	90 91 51 01 	lds	r25, 0x0151
    1406:	00 97       	sbiw	r24, 0x00	; 0
    1408:	d1 f0       	breq	.+52     	; 0x143e <__vector_6+0x6c>

		if(Number_OverFlows_16bit_Timer --){
    140a:	80 91 41 01 	lds	r24, 0x0141
    140e:	89 83       	std	Y+1, r24	; 0x01
    1410:	89 81       	ldd	r24, Y+1	; 0x01
    1412:	8a 83       	std	Y+2, r24	; 0x02
    1414:	8a 81       	ldd	r24, Y+2	; 0x02
    1416:	88 23       	and	r24, r24
    1418:	11 f0       	breq	.+4      	; 0x141e <__vector_6+0x4c>
    141a:	81 e0       	ldi	r24, 0x01	; 1
    141c:	8a 83       	std	Y+2, r24	; 0x02
    141e:	9a 81       	ldd	r25, Y+2	; 0x02
    1420:	89 81       	ldd	r24, Y+1	; 0x01
    1422:	81 50       	subi	r24, 0x01	; 1
    1424:	80 93 41 01 	sts	0x0141, r24
    1428:	81 e0       	ldi	r24, 0x01	; 1
    142a:	89 27       	eor	r24, r25
    142c:	88 23       	and	r24, r24
    142e:	39 f0       	breq	.+14     	; 0x143e <__vector_6+0x6c>

		}

		else{
		func_register_16bit_timer1[TIMER1_COMPA]();
    1430:	e0 91 50 01 	lds	r30, 0x0150
    1434:	f0 91 51 01 	lds	r31, 0x0151
    1438:	09 95       	icall

		mtimer_16bits_stop();
    143a:	0e 94 db 09 	call	0x13b6	; 0x13b6 <mtimer_16bits_stop>
		}

	}
}
    143e:	0f 90       	pop	r0
    1440:	0f 90       	pop	r0
    1442:	cf 91       	pop	r28
    1444:	df 91       	pop	r29
    1446:	ff 91       	pop	r31
    1448:	ef 91       	pop	r30
    144a:	bf 91       	pop	r27
    144c:	af 91       	pop	r26
    144e:	9f 91       	pop	r25
    1450:	8f 91       	pop	r24
    1452:	7f 91       	pop	r23
    1454:	6f 91       	pop	r22
    1456:	5f 91       	pop	r21
    1458:	4f 91       	pop	r20
    145a:	3f 91       	pop	r19
    145c:	2f 91       	pop	r18
    145e:	0f 90       	pop	r0
    1460:	0f be       	out	0x3f, r0	; 63
    1462:	0f 90       	pop	r0
    1464:	1f 90       	pop	r1
    1466:	18 95       	reti

00001468 <__vector_7>:
/****************************************************/

/************************** ID =3.11 ******************************/
ISR(TIMER1_COMPB_vect){
    1468:	1f 92       	push	r1
    146a:	0f 92       	push	r0
    146c:	0f b6       	in	r0, 0x3f	; 63
    146e:	0f 92       	push	r0
    1470:	11 24       	eor	r1, r1
    1472:	2f 93       	push	r18
    1474:	3f 93       	push	r19
    1476:	4f 93       	push	r20
    1478:	5f 93       	push	r21
    147a:	6f 93       	push	r22
    147c:	7f 93       	push	r23
    147e:	8f 93       	push	r24
    1480:	9f 93       	push	r25
    1482:	af 93       	push	r26
    1484:	bf 93       	push	r27
    1486:	ef 93       	push	r30
    1488:	ff 93       	push	r31
    148a:	df 93       	push	r29
    148c:	cf 93       	push	r28
    148e:	cd b7       	in	r28, 0x3d	; 61
    1490:	de b7       	in	r29, 0x3e	; 62
	if(func_register_16bit_timer1[TIMER1_COMPB] != NULL_PTR){
    1492:	80 91 52 01 	lds	r24, 0x0152
    1496:	90 91 53 01 	lds	r25, 0x0153
    149a:	00 97       	sbiw	r24, 0x00	; 0
    149c:	39 f0       	breq	.+14     	; 0x14ac <__vector_7+0x44>
		func_register_16bit_timer1[TIMER1_COMPB]();
    149e:	e0 91 52 01 	lds	r30, 0x0152
    14a2:	f0 91 53 01 	lds	r31, 0x0153
    14a6:	09 95       	icall

		mtimer_16bits_stop();
    14a8:	0e 94 db 09 	call	0x13b6	; 0x13b6 <mtimer_16bits_stop>
	}
	  }
    14ac:	cf 91       	pop	r28
    14ae:	df 91       	pop	r29
    14b0:	ff 91       	pop	r31
    14b2:	ef 91       	pop	r30
    14b4:	bf 91       	pop	r27
    14b6:	af 91       	pop	r26
    14b8:	9f 91       	pop	r25
    14ba:	8f 91       	pop	r24
    14bc:	7f 91       	pop	r23
    14be:	6f 91       	pop	r22
    14c0:	5f 91       	pop	r21
    14c2:	4f 91       	pop	r20
    14c4:	3f 91       	pop	r19
    14c6:	2f 91       	pop	r18
    14c8:	0f 90       	pop	r0
    14ca:	0f be       	out	0x3f, r0	; 63
    14cc:	0f 90       	pop	r0
    14ce:	1f 90       	pop	r1
    14d0:	18 95       	reti

000014d2 <__vector_5>:
/****************************************************/
/************************** ID =3.12 ******************************/
ISR(TIMER1_CAPT_vect){
    14d2:	1f 92       	push	r1
    14d4:	0f 92       	push	r0
    14d6:	0f b6       	in	r0, 0x3f	; 63
    14d8:	0f 92       	push	r0
    14da:	11 24       	eor	r1, r1
    14dc:	2f 93       	push	r18
    14de:	3f 93       	push	r19
    14e0:	4f 93       	push	r20
    14e2:	5f 93       	push	r21
    14e4:	6f 93       	push	r22
    14e6:	7f 93       	push	r23
    14e8:	8f 93       	push	r24
    14ea:	9f 93       	push	r25
    14ec:	af 93       	push	r26
    14ee:	bf 93       	push	r27
    14f0:	ef 93       	push	r30
    14f2:	ff 93       	push	r31
    14f4:	df 93       	push	r29
    14f6:	cf 93       	push	r28
    14f8:	cd b7       	in	r28, 0x3d	; 61
    14fa:	de b7       	in	r29, 0x3e	; 62
	if(func_register_16bit_timer1[TIMER1_CAPT] != NULL_PTR){
    14fc:	80 91 54 01 	lds	r24, 0x0154
    1500:	90 91 55 01 	lds	r25, 0x0155
    1504:	00 97       	sbiw	r24, 0x00	; 0
    1506:	39 f0       	breq	.+14     	; 0x1516 <__vector_5+0x44>
		func_register_16bit_timer1[TIMER1_CAPT]();
    1508:	e0 91 54 01 	lds	r30, 0x0154
    150c:	f0 91 55 01 	lds	r31, 0x0155
    1510:	09 95       	icall

		mtimer_16bits_stop();
    1512:	0e 94 db 09 	call	0x13b6	; 0x13b6 <mtimer_16bits_stop>
	}

}
    1516:	cf 91       	pop	r28
    1518:	df 91       	pop	r29
    151a:	ff 91       	pop	r31
    151c:	ef 91       	pop	r30
    151e:	bf 91       	pop	r27
    1520:	af 91       	pop	r26
    1522:	9f 91       	pop	r25
    1524:	8f 91       	pop	r24
    1526:	7f 91       	pop	r23
    1528:	6f 91       	pop	r22
    152a:	5f 91       	pop	r21
    152c:	4f 91       	pop	r20
    152e:	3f 91       	pop	r19
    1530:	2f 91       	pop	r18
    1532:	0f 90       	pop	r0
    1534:	0f be       	out	0x3f, r0	; 63
    1536:	0f 90       	pop	r0
    1538:	1f 90       	pop	r1
    153a:	18 95       	reti

0000153c <DelayTimer_8bits_Init>:
/********************************************  8BIT TIMER  ********************************************************************/
/* the user have the option to select between timer0 and timer2 for initializing the delay function
 * by using the timerIndex  which is an index of the array of pointers to registers */

/************************** ID =3.13 ******************************/
void  DelayTimer_8bits_Init ( DelayMode_8bit_Config_t * ptr_delayTimer , u8_t timerIndex){
    153c:	df 93       	push	r29
    153e:	cf 93       	push	r28
    1540:	00 d0       	rcall	.+0      	; 0x1542 <DelayTimer_8bits_Init+0x6>
    1542:	0f 92       	push	r0
    1544:	cd b7       	in	r28, 0x3d	; 61
    1546:	de b7       	in	r29, 0x3e	; 62
    1548:	9a 83       	std	Y+2, r25	; 0x02
    154a:	89 83       	std	Y+1, r24	; 0x01
    154c:	6b 83       	std	Y+3, r22	; 0x03

	 *Timer_8bits_Control_Register[timerIndex] |= (1<<TCCR_WAVE_GENERATION_CTC);
    154e:	8b 81       	ldd	r24, Y+3	; 0x03
    1550:	88 2f       	mov	r24, r24
    1552:	90 e0       	ldi	r25, 0x00	; 0
    1554:	88 0f       	add	r24, r24
    1556:	99 1f       	adc	r25, r25
    1558:	fc 01       	movw	r30, r24
    155a:	e4 5d       	subi	r30, 0xD4	; 212
    155c:	fe 4f       	sbci	r31, 0xFE	; 254
    155e:	a0 81       	ld	r26, Z
    1560:	b1 81       	ldd	r27, Z+1	; 0x01
    1562:	8b 81       	ldd	r24, Y+3	; 0x03
    1564:	88 2f       	mov	r24, r24
    1566:	90 e0       	ldi	r25, 0x00	; 0
    1568:	88 0f       	add	r24, r24
    156a:	99 1f       	adc	r25, r25
    156c:	fc 01       	movw	r30, r24
    156e:	e4 5d       	subi	r30, 0xD4	; 212
    1570:	fe 4f       	sbci	r31, 0xFE	; 254
    1572:	01 90       	ld	r0, Z+
    1574:	f0 81       	ld	r31, Z
    1576:	e0 2d       	mov	r30, r0
    1578:	80 81       	ld	r24, Z
    157a:	88 60       	ori	r24, 0x08	; 8
    157c:	8c 93       	st	X, r24
	 *Timer_8bits_Control_Register[timerIndex] &= ~(1<< TCCR_WAVE_GENERATION_PWM);
    157e:	8b 81       	ldd	r24, Y+3	; 0x03
    1580:	88 2f       	mov	r24, r24
    1582:	90 e0       	ldi	r25, 0x00	; 0
    1584:	88 0f       	add	r24, r24
    1586:	99 1f       	adc	r25, r25
    1588:	fc 01       	movw	r30, r24
    158a:	e4 5d       	subi	r30, 0xD4	; 212
    158c:	fe 4f       	sbci	r31, 0xFE	; 254
    158e:	a0 81       	ld	r26, Z
    1590:	b1 81       	ldd	r27, Z+1	; 0x01
    1592:	8b 81       	ldd	r24, Y+3	; 0x03
    1594:	88 2f       	mov	r24, r24
    1596:	90 e0       	ldi	r25, 0x00	; 0
    1598:	88 0f       	add	r24, r24
    159a:	99 1f       	adc	r25, r25
    159c:	fc 01       	movw	r30, r24
    159e:	e4 5d       	subi	r30, 0xD4	; 212
    15a0:	fe 4f       	sbci	r31, 0xFE	; 254
    15a2:	01 90       	ld	r0, Z+
    15a4:	f0 81       	ld	r31, Z
    15a6:	e0 2d       	mov	r30, r0
    15a8:	80 81       	ld	r24, Z
    15aa:	8f 7b       	andi	r24, 0xBF	; 191
    15ac:	8c 93       	st	X, r24
	 /* Clear bit 6 and set bit 3 in timer control register 0 OR timer control register 2
	  * according to the index inserted */


	  gu8_timer_8bits_SelectedPrescaler[timerIndex]  = (ptr_delayTimer->prescaler);
    15ae:	8b 81       	ldd	r24, Y+3	; 0x03
    15b0:	88 2f       	mov	r24, r24
    15b2:	90 e0       	ldi	r25, 0x00	; 0
    15b4:	e9 81       	ldd	r30, Y+1	; 0x01
    15b6:	fa 81       	ldd	r31, Y+2	; 0x02
    15b8:	20 81       	ld	r18, Z
    15ba:	fc 01       	movw	r30, r24
    15bc:	e3 5c       	subi	r30, 0xC3	; 195
    15be:	fe 4f       	sbci	r31, 0xFE	; 254
    15c0:	20 83       	st	Z, r18

	 *Timer_8bits_Compare_Match_Register[timerIndex] =(ptr_delayTimer->CompareValue);
    15c2:	8b 81       	ldd	r24, Y+3	; 0x03
    15c4:	88 2f       	mov	r24, r24
    15c6:	90 e0       	ldi	r25, 0x00	; 0
    15c8:	88 0f       	add	r24, r24
    15ca:	99 1f       	adc	r25, r25
    15cc:	fc 01       	movw	r30, r24
    15ce:	e0 5d       	subi	r30, 0xD0	; 208
    15d0:	fe 4f       	sbci	r31, 0xFE	; 254
    15d2:	a0 81       	ld	r26, Z
    15d4:	b1 81       	ldd	r27, Z+1	; 0x01
    15d6:	e9 81       	ldd	r30, Y+1	; 0x01
    15d8:	fa 81       	ldd	r31, Y+2	; 0x02
    15da:	81 81       	ldd	r24, Z+1	; 0x01
    15dc:	8c 93       	st	X, r24

	 *Timer_8bits_Control_Register[timerIndex] &=~(TCCR_COMPARE_MATCH_0) &~(TCCR_COMPARE_MATCH_1);
    15de:	8b 81       	ldd	r24, Y+3	; 0x03
    15e0:	88 2f       	mov	r24, r24
    15e2:	90 e0       	ldi	r25, 0x00	; 0
    15e4:	88 0f       	add	r24, r24
    15e6:	99 1f       	adc	r25, r25
    15e8:	fc 01       	movw	r30, r24
    15ea:	e4 5d       	subi	r30, 0xD4	; 212
    15ec:	fe 4f       	sbci	r31, 0xFE	; 254
    15ee:	a0 81       	ld	r26, Z
    15f0:	b1 81       	ldd	r27, Z+1	; 0x01
    15f2:	8b 81       	ldd	r24, Y+3	; 0x03
    15f4:	88 2f       	mov	r24, r24
    15f6:	90 e0       	ldi	r25, 0x00	; 0
    15f8:	88 0f       	add	r24, r24
    15fa:	99 1f       	adc	r25, r25
    15fc:	fc 01       	movw	r30, r24
    15fe:	e4 5d       	subi	r30, 0xD4	; 212
    1600:	fe 4f       	sbci	r31, 0xFE	; 254
    1602:	01 90       	ld	r0, Z+
    1604:	f0 81       	ld	r31, Z
    1606:	e0 2d       	mov	r30, r0
    1608:	80 81       	ld	r24, Z
    160a:	8a 7f       	andi	r24, 0xFA	; 250
    160c:	8c 93       	st	X, r24
		/* No need to connect the OC0 in the overflow and the delay mode
	       it will be connected in the PWM mode because in the delay mode
	       it will not give an interrupt every time there is a compare match  */


}
    160e:	0f 90       	pop	r0
    1610:	0f 90       	pop	r0
    1612:	0f 90       	pop	r0
    1614:	cf 91       	pop	r28
    1616:	df 91       	pop	r29
    1618:	08 95       	ret

0000161a <DelayTimer_8bits_synchrounous>:
/********************************************  8BIT TIMER  ********************************************************************/
/************************** ID =3.14 ******************************/
void  DelayTimer_8bits_synchrounous(u16_t au8_delayTime,u8_t timerIndex){
    161a:	df 93       	push	r29
    161c:	cf 93       	push	r28
    161e:	00 d0       	rcall	.+0      	; 0x1620 <DelayTimer_8bits_synchrounous+0x6>
    1620:	00 d0       	rcall	.+0      	; 0x1622 <DelayTimer_8bits_synchrounous+0x8>
    1622:	cd b7       	in	r28, 0x3d	; 61
    1624:	de b7       	in	r29, 0x3e	; 62
    1626:	9a 83       	std	Y+2, r25	; 0x02
    1628:	89 83       	std	Y+1, r24	; 0x01
    162a:	6b 83       	std	Y+3, r22	; 0x03


				//}
/***************************************************************************************************************/

	 mtimer_8bits_start(timerIndex); /* pre-scaling value inserted */
    162c:	8b 81       	ldd	r24, Y+3	; 0x03
    162e:	0e 94 66 0b 	call	0x16cc	; 0x16cc <mtimer_8bits_start>
    1632:	32 c0       	rjmp	.+100    	; 0x1698 <DelayTimer_8bits_synchrounous+0x7e>

	/*Looping over the time */
	 while(au8_delayTime--){

		 while( 0 == GET_BIT(MTIMER_TIFR,TIMER_OUTPUT_COMPARE_FLAG_BIT[timerIndex]) );
    1634:	e8 e5       	ldi	r30, 0x58	; 88
    1636:	f0 e0       	ldi	r31, 0x00	; 0
    1638:	80 81       	ld	r24, Z
    163a:	28 2f       	mov	r18, r24
    163c:	30 e0       	ldi	r19, 0x00	; 0
    163e:	8b 81       	ldd	r24, Y+3	; 0x03
    1640:	88 2f       	mov	r24, r24
    1642:	90 e0       	ldi	r25, 0x00	; 0
    1644:	fc 01       	movw	r30, r24
    1646:	ef 5f       	subi	r30, 0xFF	; 255
    1648:	fe 4f       	sbci	r31, 0xFE	; 254
    164a:	80 81       	ld	r24, Z
    164c:	88 2f       	mov	r24, r24
    164e:	90 e0       	ldi	r25, 0x00	; 0
    1650:	a9 01       	movw	r20, r18
    1652:	02 c0       	rjmp	.+4      	; 0x1658 <DelayTimer_8bits_synchrounous+0x3e>
    1654:	55 95       	asr	r21
    1656:	47 95       	ror	r20
    1658:	8a 95       	dec	r24
    165a:	e2 f7       	brpl	.-8      	; 0x1654 <DelayTimer_8bits_synchrounous+0x3a>
    165c:	ca 01       	movw	r24, r20
    165e:	81 70       	andi	r24, 0x01	; 1
    1660:	90 70       	andi	r25, 0x00	; 0
    1662:	00 97       	sbiw	r24, 0x00	; 0
    1664:	39 f3       	breq	.-50     	; 0x1634 <DelayTimer_8bits_synchrounous+0x1a>

		 /*Clearing the OCF0 flag*/
		 SET_BIT(MTIMER_TIFR, TIMER_OUTPUT_COMPARE_FLAG_BIT[timerIndex]);
    1666:	a8 e5       	ldi	r26, 0x58	; 88
    1668:	b0 e0       	ldi	r27, 0x00	; 0
    166a:	e8 e5       	ldi	r30, 0x58	; 88
    166c:	f0 e0       	ldi	r31, 0x00	; 0
    166e:	80 81       	ld	r24, Z
    1670:	48 2f       	mov	r20, r24
    1672:	8b 81       	ldd	r24, Y+3	; 0x03
    1674:	88 2f       	mov	r24, r24
    1676:	90 e0       	ldi	r25, 0x00	; 0
    1678:	fc 01       	movw	r30, r24
    167a:	ef 5f       	subi	r30, 0xFF	; 255
    167c:	fe 4f       	sbci	r31, 0xFE	; 254
    167e:	80 81       	ld	r24, Z
    1680:	28 2f       	mov	r18, r24
    1682:	30 e0       	ldi	r19, 0x00	; 0
    1684:	81 e0       	ldi	r24, 0x01	; 1
    1686:	90 e0       	ldi	r25, 0x00	; 0
    1688:	02 2e       	mov	r0, r18
    168a:	02 c0       	rjmp	.+4      	; 0x1690 <DelayTimer_8bits_synchrounous+0x76>
    168c:	88 0f       	add	r24, r24
    168e:	99 1f       	adc	r25, r25
    1690:	0a 94       	dec	r0
    1692:	e2 f7       	brpl	.-8      	; 0x168c <DelayTimer_8bits_synchrounous+0x72>
    1694:	84 2b       	or	r24, r20
    1696:	8c 93       	st	X, r24
/***************************************************************************************************************/

	 mtimer_8bits_start(timerIndex); /* pre-scaling value inserted */

	/*Looping over the time */
	 while(au8_delayTime--){
    1698:	1c 82       	std	Y+4, r1	; 0x04
    169a:	89 81       	ldd	r24, Y+1	; 0x01
    169c:	9a 81       	ldd	r25, Y+2	; 0x02
    169e:	00 97       	sbiw	r24, 0x00	; 0
    16a0:	11 f0       	breq	.+4      	; 0x16a6 <DelayTimer_8bits_synchrounous+0x8c>
    16a2:	51 e0       	ldi	r21, 0x01	; 1
    16a4:	5c 83       	std	Y+4, r21	; 0x04
    16a6:	89 81       	ldd	r24, Y+1	; 0x01
    16a8:	9a 81       	ldd	r25, Y+2	; 0x02
    16aa:	01 97       	sbiw	r24, 0x01	; 1
    16ac:	9a 83       	std	Y+2, r25	; 0x02
    16ae:	89 83       	std	Y+1, r24	; 0x01
    16b0:	8c 81       	ldd	r24, Y+4	; 0x04
    16b2:	88 23       	and	r24, r24
    16b4:	09 f0       	breq	.+2      	; 0x16b8 <DelayTimer_8bits_synchrounous+0x9e>
    16b6:	be cf       	rjmp	.-132    	; 0x1634 <DelayTimer_8bits_synchrounous+0x1a>
		 /*Clearing the OCF0 flag*/
		 SET_BIT(MTIMER_TIFR, TIMER_OUTPUT_COMPARE_FLAG_BIT[timerIndex]);

	 }

	 mtimer_8bits_stop(timerIndex); /* pre-scaling value cleared*/
    16b8:	8b 81       	ldd	r24, Y+3	; 0x03
    16ba:	0e 94 7e 08 	call	0x10fc	; 0x10fc <mtimer_8bits_stop>


}
    16be:	0f 90       	pop	r0
    16c0:	0f 90       	pop	r0
    16c2:	0f 90       	pop	r0
    16c4:	0f 90       	pop	r0
    16c6:	cf 91       	pop	r28
    16c8:	df 91       	pop	r29
    16ca:	08 95       	ret

000016cc <mtimer_8bits_start>:

/********************************************  8BIT TIMER  ********************************************************************/

/************************** ID =3.1 ******************************/
void static inline mtimer_8bits_start(u8_t timerIndex)
{
    16cc:	df 93       	push	r29
    16ce:	cf 93       	push	r28
    16d0:	0f 92       	push	r0
    16d2:	cd b7       	in	r28, 0x3d	; 61
    16d4:	de b7       	in	r29, 0x3e	; 62
    16d6:	89 83       	std	Y+1, r24	; 0x01

	/*Resetting the selected timer counter*/
    *Timer_8bits_Counter_Register[timerIndex]= 0;
    16d8:	89 81       	ldd	r24, Y+1	; 0x01
    16da:	88 2f       	mov	r24, r24
    16dc:	90 e0       	ldi	r25, 0x00	; 0
    16de:	88 0f       	add	r24, r24
    16e0:	99 1f       	adc	r25, r25
    16e2:	fc 01       	movw	r30, r24
    16e4:	ec 5c       	subi	r30, 0xCC	; 204
    16e6:	fe 4f       	sbci	r31, 0xFE	; 254
    16e8:	01 90       	ld	r0, Z+
    16ea:	f0 81       	ld	r31, Z
    16ec:	e0 2d       	mov	r30, r0
    16ee:	10 82       	st	Z, r1

	/*Clear the bits responsible for the clock selection of the selected timer*/
	*Timer_8bits_Control_Register[timerIndex] &= ~(1<<TCCR_CLOCK_SELECT_0) & ~(1<<TCCR_CLOCK_SELECT_1) & ~(1<<TCCR_CLOCK_SELECT_2);
    16f0:	89 81       	ldd	r24, Y+1	; 0x01
    16f2:	88 2f       	mov	r24, r24
    16f4:	90 e0       	ldi	r25, 0x00	; 0
    16f6:	88 0f       	add	r24, r24
    16f8:	99 1f       	adc	r25, r25
    16fa:	fc 01       	movw	r30, r24
    16fc:	e4 5d       	subi	r30, 0xD4	; 212
    16fe:	fe 4f       	sbci	r31, 0xFE	; 254
    1700:	a0 81       	ld	r26, Z
    1702:	b1 81       	ldd	r27, Z+1	; 0x01
    1704:	89 81       	ldd	r24, Y+1	; 0x01
    1706:	88 2f       	mov	r24, r24
    1708:	90 e0       	ldi	r25, 0x00	; 0
    170a:	88 0f       	add	r24, r24
    170c:	99 1f       	adc	r25, r25
    170e:	fc 01       	movw	r30, r24
    1710:	e4 5d       	subi	r30, 0xD4	; 212
    1712:	fe 4f       	sbci	r31, 0xFE	; 254
    1714:	01 90       	ld	r0, Z+
    1716:	f0 81       	ld	r31, Z
    1718:	e0 2d       	mov	r30, r0
    171a:	80 81       	ld	r24, Z
    171c:	88 7f       	andi	r24, 0xF8	; 248
    171e:	8c 93       	st	X, r24

	/*Adding the previous selected timer pre-scaler*/
	 *Timer_8bits_Control_Register[timerIndex] |= gu8_timer_8bits_SelectedPrescaler[timerIndex];
    1720:	89 81       	ldd	r24, Y+1	; 0x01
    1722:	88 2f       	mov	r24, r24
    1724:	90 e0       	ldi	r25, 0x00	; 0
    1726:	88 0f       	add	r24, r24
    1728:	99 1f       	adc	r25, r25
    172a:	fc 01       	movw	r30, r24
    172c:	e4 5d       	subi	r30, 0xD4	; 212
    172e:	fe 4f       	sbci	r31, 0xFE	; 254
    1730:	a0 81       	ld	r26, Z
    1732:	b1 81       	ldd	r27, Z+1	; 0x01
    1734:	89 81       	ldd	r24, Y+1	; 0x01
    1736:	88 2f       	mov	r24, r24
    1738:	90 e0       	ldi	r25, 0x00	; 0
    173a:	88 0f       	add	r24, r24
    173c:	99 1f       	adc	r25, r25
    173e:	fc 01       	movw	r30, r24
    1740:	e4 5d       	subi	r30, 0xD4	; 212
    1742:	fe 4f       	sbci	r31, 0xFE	; 254
    1744:	01 90       	ld	r0, Z+
    1746:	f0 81       	ld	r31, Z
    1748:	e0 2d       	mov	r30, r0
    174a:	20 81       	ld	r18, Z
    174c:	89 81       	ldd	r24, Y+1	; 0x01
    174e:	88 2f       	mov	r24, r24
    1750:	90 e0       	ldi	r25, 0x00	; 0
    1752:	fc 01       	movw	r30, r24
    1754:	e3 5c       	subi	r30, 0xC3	; 195
    1756:	fe 4f       	sbci	r31, 0xFE	; 254
    1758:	80 81       	ld	r24, Z
    175a:	82 2b       	or	r24, r18
    175c:	8c 93       	st	X, r24

	 return;

}
    175e:	0f 90       	pop	r0
    1760:	cf 91       	pop	r28
    1762:	df 91       	pop	r29
    1764:	08 95       	ret

00001766 <DelayTimer_8bits_Asynchrounous>:


}
/********************************************  8BIT TIMER  ********************************************************************/
/************************** ID =3.15 ******************************/
void  DelayTimer_8bits_Asynchrounous(u8_t timerIndex, u8_t au8_delayTime, CallbackFunc_t p_callback_func){
    1766:	df 93       	push	r29
    1768:	cf 93       	push	r28
    176a:	00 d0       	rcall	.+0      	; 0x176c <DelayTimer_8bits_Asynchrounous+0x6>
    176c:	00 d0       	rcall	.+0      	; 0x176e <DelayTimer_8bits_Asynchrounous+0x8>
    176e:	cd b7       	in	r28, 0x3d	; 61
    1770:	de b7       	in	r29, 0x3e	; 62
    1772:	89 83       	std	Y+1, r24	; 0x01
    1774:	6a 83       	std	Y+2, r22	; 0x02
    1776:	5c 83       	std	Y+4, r21	; 0x04
    1778:	4b 83       	std	Y+3, r20	; 0x03
					//}
	/***************************************************************************************************************/



	mtimer_8bits_start(timerIndex); /* pre-scaling value inserted */
    177a:	89 81       	ldd	r24, Y+1	; 0x01
    177c:	0e 94 66 0b 	call	0x16cc	; 0x16cc <mtimer_8bits_start>

	gu8_delayTime[2]= au8_delayTime;
    1780:	8a 81       	ldd	r24, Y+2	; 0x02
    1782:	80 93 41 01 	sts	0x0141, r24

	func_register_8bit_compare[timerIndex]=p_callback_func;
    1786:	89 81       	ldd	r24, Y+1	; 0x01
    1788:	88 2f       	mov	r24, r24
    178a:	90 e0       	ldi	r25, 0x00	; 0
    178c:	88 0f       	add	r24, r24
    178e:	99 1f       	adc	r25, r25
    1790:	fc 01       	movw	r30, r24
    1792:	e6 5b       	subi	r30, 0xB6	; 182
    1794:	fe 4f       	sbci	r31, 0xFE	; 254
    1796:	8b 81       	ldd	r24, Y+3	; 0x03
    1798:	9c 81       	ldd	r25, Y+4	; 0x04
    179a:	91 83       	std	Z+1, r25	; 0x01
    179c:	80 83       	st	Z, r24
	/* register the callback function to be executed in the ISR
	 * when the interrupt occurs  */

	SET_BIT(MTIMER_TIMSK,TIMER_INTERRUPT_COMPARE_ENABLE_BIT[timerIndex]);
    179e:	a9 e5       	ldi	r26, 0x59	; 89
    17a0:	b0 e0       	ldi	r27, 0x00	; 0
    17a2:	e9 e5       	ldi	r30, 0x59	; 89
    17a4:	f0 e0       	ldi	r31, 0x00	; 0
    17a6:	80 81       	ld	r24, Z
    17a8:	48 2f       	mov	r20, r24
    17aa:	89 81       	ldd	r24, Y+1	; 0x01
    17ac:	88 2f       	mov	r24, r24
    17ae:	90 e0       	ldi	r25, 0x00	; 0
    17b0:	fc 01       	movw	r30, r24
    17b2:	eb 5f       	subi	r30, 0xFB	; 251
    17b4:	fe 4f       	sbci	r31, 0xFE	; 254
    17b6:	80 81       	ld	r24, Z
    17b8:	28 2f       	mov	r18, r24
    17ba:	30 e0       	ldi	r19, 0x00	; 0
    17bc:	81 e0       	ldi	r24, 0x01	; 1
    17be:	90 e0       	ldi	r25, 0x00	; 0
    17c0:	02 2e       	mov	r0, r18
    17c2:	02 c0       	rjmp	.+4      	; 0x17c8 <DelayTimer_8bits_Asynchrounous+0x62>
    17c4:	88 0f       	add	r24, r24
    17c6:	99 1f       	adc	r25, r25
    17c8:	0a 94       	dec	r0
    17ca:	e2 f7       	brpl	.-8      	; 0x17c4 <DelayTimer_8bits_Asynchrounous+0x5e>
    17cc:	84 2b       	or	r24, r20
    17ce:	8c 93       	st	X, r24


}
    17d0:	0f 90       	pop	r0
    17d2:	0f 90       	pop	r0
    17d4:	0f 90       	pop	r0
    17d6:	0f 90       	pop	r0
    17d8:	cf 91       	pop	r28
    17da:	df 91       	pop	r29
    17dc:	08 95       	ret

000017de <OverflowTimer_8bits_Init>:
/****************************************************************************************************************************************/
/********************************************  NORMAL MODE *******************************************************************************/
/****************************************************************************************************************************************/

/************************** ID =3.16 ******************************/
void  OverflowTimer_8bits_Init(u8_t timerIndex, mtimerPrescaler_t Prescaler ){
    17de:	df 93       	push	r29
    17e0:	cf 93       	push	r28
    17e2:	00 d0       	rcall	.+0      	; 0x17e4 <OverflowTimer_8bits_Init+0x6>
    17e4:	cd b7       	in	r28, 0x3d	; 61
    17e6:	de b7       	in	r29, 0x3e	; 62
    17e8:	89 83       	std	Y+1, r24	; 0x01
    17ea:	6a 83       	std	Y+2, r22	; 0x02

	*Timer_8bits_Control_Register[timerIndex] &= ~(1<< TCCR_WAVE_GENERATION_PWM) & ~(1<<TCCR_WAVE_GENERATION_CTC);
    17ec:	89 81       	ldd	r24, Y+1	; 0x01
    17ee:	88 2f       	mov	r24, r24
    17f0:	90 e0       	ldi	r25, 0x00	; 0
    17f2:	88 0f       	add	r24, r24
    17f4:	99 1f       	adc	r25, r25
    17f6:	fc 01       	movw	r30, r24
    17f8:	e4 5d       	subi	r30, 0xD4	; 212
    17fa:	fe 4f       	sbci	r31, 0xFE	; 254
    17fc:	a0 81       	ld	r26, Z
    17fe:	b1 81       	ldd	r27, Z+1	; 0x01
    1800:	89 81       	ldd	r24, Y+1	; 0x01
    1802:	88 2f       	mov	r24, r24
    1804:	90 e0       	ldi	r25, 0x00	; 0
    1806:	88 0f       	add	r24, r24
    1808:	99 1f       	adc	r25, r25
    180a:	fc 01       	movw	r30, r24
    180c:	e4 5d       	subi	r30, 0xD4	; 212
    180e:	fe 4f       	sbci	r31, 0xFE	; 254
    1810:	01 90       	ld	r0, Z+
    1812:	f0 81       	ld	r31, Z
    1814:	e0 2d       	mov	r30, r0
    1816:	80 81       	ld	r24, Z
    1818:	87 7b       	andi	r24, 0xB7	; 183
    181a:	8c 93       	st	X, r24
      /* Clear bit 6 and bit 3 in timer control register 0 OR timer control register 2
       * according to the index inserted */

	gu8_timer_8bits_SelectedPrescaler[timerIndex]= Prescaler;
    181c:	89 81       	ldd	r24, Y+1	; 0x01
    181e:	88 2f       	mov	r24, r24
    1820:	90 e0       	ldi	r25, 0x00	; 0
    1822:	fc 01       	movw	r30, r24
    1824:	e3 5c       	subi	r30, 0xC3	; 195
    1826:	fe 4f       	sbci	r31, 0xFE	; 254
    1828:	8a 81       	ldd	r24, Y+2	; 0x02
    182a:	80 83       	st	Z, r24
	/* don't start the timer now
	 * so, you can store that value in a global variable
	 * to use it in the synchrounous or the Asynchrounous function*/


	*Timer_8bits_Control_Register[timerIndex] &=~(TCCR_COMPARE_MATCH_0) &~(TCCR_COMPARE_MATCH_1);
    182c:	89 81       	ldd	r24, Y+1	; 0x01
    182e:	88 2f       	mov	r24, r24
    1830:	90 e0       	ldi	r25, 0x00	; 0
    1832:	88 0f       	add	r24, r24
    1834:	99 1f       	adc	r25, r25
    1836:	fc 01       	movw	r30, r24
    1838:	e4 5d       	subi	r30, 0xD4	; 212
    183a:	fe 4f       	sbci	r31, 0xFE	; 254
    183c:	a0 81       	ld	r26, Z
    183e:	b1 81       	ldd	r27, Z+1	; 0x01
    1840:	89 81       	ldd	r24, Y+1	; 0x01
    1842:	88 2f       	mov	r24, r24
    1844:	90 e0       	ldi	r25, 0x00	; 0
    1846:	88 0f       	add	r24, r24
    1848:	99 1f       	adc	r25, r25
    184a:	fc 01       	movw	r30, r24
    184c:	e4 5d       	subi	r30, 0xD4	; 212
    184e:	fe 4f       	sbci	r31, 0xFE	; 254
    1850:	01 90       	ld	r0, Z+
    1852:	f0 81       	ld	r31, Z
    1854:	e0 2d       	mov	r30, r0
    1856:	80 81       	ld	r24, Z
    1858:	8a 7f       	andi	r24, 0xFA	; 250
    185a:	8c 93       	st	X, r24
	/* No need to connect the OC0 in the overflow and the delay mode
       it will be connected in the PWM mode because in the delay mode
       it will not give an interrupt every time there is a compare match  */

}
    185c:	0f 90       	pop	r0
    185e:	0f 90       	pop	r0
    1860:	cf 91       	pop	r28
    1862:	df 91       	pop	r29
    1864:	08 95       	ret

00001866 <OverflowTimer_8bits_synchrounous>:
/********************************************  8BIT TIMER  ********************************************************************/

/************************** ID =3.17 ******************************/
void  OverflowTimer_8bits_synchrounous(u8_t Number_OverFlows,u8_t timerIndex){
    1866:	df 93       	push	r29
    1868:	cf 93       	push	r28
    186a:	00 d0       	rcall	.+0      	; 0x186c <OverflowTimer_8bits_synchrounous+0x6>
    186c:	0f 92       	push	r0
    186e:	cd b7       	in	r28, 0x3d	; 61
    1870:	de b7       	in	r29, 0x3e	; 62
    1872:	89 83       	std	Y+1, r24	; 0x01
    1874:	6a 83       	std	Y+2, r22	; 0x02

					//}
	/***************************************************************************************************************/


	mtimer_8bits_start(timerIndex);
    1876:	8a 81       	ldd	r24, Y+2	; 0x02
    1878:	0e 94 66 0b 	call	0x16cc	; 0x16cc <mtimer_8bits_start>
    187c:	32 c0       	rjmp	.+100    	; 0x18e2 <OverflowTimer_8bits_synchrounous+0x7c>
	 according to the index inserted*/


	while(Number_OverFlows--){

	while( 0 == GET_BIT(MTIMER_TIFR,TIMER_OUTPUT_COMPARE_FLAG_BIT[timerIndex]) );
    187e:	e8 e5       	ldi	r30, 0x58	; 88
    1880:	f0 e0       	ldi	r31, 0x00	; 0
    1882:	80 81       	ld	r24, Z
    1884:	28 2f       	mov	r18, r24
    1886:	30 e0       	ldi	r19, 0x00	; 0
    1888:	8a 81       	ldd	r24, Y+2	; 0x02
    188a:	88 2f       	mov	r24, r24
    188c:	90 e0       	ldi	r25, 0x00	; 0
    188e:	fc 01       	movw	r30, r24
    1890:	ef 5f       	subi	r30, 0xFF	; 255
    1892:	fe 4f       	sbci	r31, 0xFE	; 254
    1894:	80 81       	ld	r24, Z
    1896:	88 2f       	mov	r24, r24
    1898:	90 e0       	ldi	r25, 0x00	; 0
    189a:	a9 01       	movw	r20, r18
    189c:	02 c0       	rjmp	.+4      	; 0x18a2 <OverflowTimer_8bits_synchrounous+0x3c>
    189e:	55 95       	asr	r21
    18a0:	47 95       	ror	r20
    18a2:	8a 95       	dec	r24
    18a4:	e2 f7       	brpl	.-8      	; 0x189e <OverflowTimer_8bits_synchrounous+0x38>
    18a6:	ca 01       	movw	r24, r20
    18a8:	81 70       	andi	r24, 0x01	; 1
    18aa:	90 70       	andi	r25, 0x00	; 0
    18ac:	00 97       	sbiw	r24, 0x00	; 0
    18ae:	39 f3       	breq	.-50     	; 0x187e <OverflowTimer_8bits_synchrounous+0x18>

	 /*Clearing the OCF0 flag*/
	 SET_BIT(MTIMER_TIFR, TIMER_OUTPUT_COMPARE_FLAG_BIT[timerIndex]);
    18b0:	a8 e5       	ldi	r26, 0x58	; 88
    18b2:	b0 e0       	ldi	r27, 0x00	; 0
    18b4:	e8 e5       	ldi	r30, 0x58	; 88
    18b6:	f0 e0       	ldi	r31, 0x00	; 0
    18b8:	80 81       	ld	r24, Z
    18ba:	48 2f       	mov	r20, r24
    18bc:	8a 81       	ldd	r24, Y+2	; 0x02
    18be:	88 2f       	mov	r24, r24
    18c0:	90 e0       	ldi	r25, 0x00	; 0
    18c2:	fc 01       	movw	r30, r24
    18c4:	ef 5f       	subi	r30, 0xFF	; 255
    18c6:	fe 4f       	sbci	r31, 0xFE	; 254
    18c8:	80 81       	ld	r24, Z
    18ca:	28 2f       	mov	r18, r24
    18cc:	30 e0       	ldi	r19, 0x00	; 0
    18ce:	81 e0       	ldi	r24, 0x01	; 1
    18d0:	90 e0       	ldi	r25, 0x00	; 0
    18d2:	02 2e       	mov	r0, r18
    18d4:	02 c0       	rjmp	.+4      	; 0x18da <OverflowTimer_8bits_synchrounous+0x74>
    18d6:	88 0f       	add	r24, r24
    18d8:	99 1f       	adc	r25, r25
    18da:	0a 94       	dec	r0
    18dc:	e2 f7       	brpl	.-8      	; 0x18d6 <OverflowTimer_8bits_synchrounous+0x70>
    18de:	84 2b       	or	r24, r20
    18e0:	8c 93       	st	X, r24
	/* pre-scaling value inserted
	 in timer0 OR timer2 register
	 according to the index inserted*/


	while(Number_OverFlows--){
    18e2:	59 81       	ldd	r21, Y+1	; 0x01
    18e4:	5b 83       	std	Y+3, r21	; 0x03
    18e6:	8b 81       	ldd	r24, Y+3	; 0x03
    18e8:	88 23       	and	r24, r24
    18ea:	11 f0       	breq	.+4      	; 0x18f0 <OverflowTimer_8bits_synchrounous+0x8a>
    18ec:	41 e0       	ldi	r20, 0x01	; 1
    18ee:	4b 83       	std	Y+3, r20	; 0x03
    18f0:	8b 81       	ldd	r24, Y+3	; 0x03
    18f2:	99 81       	ldd	r25, Y+1	; 0x01
    18f4:	91 50       	subi	r25, 0x01	; 1
    18f6:	99 83       	std	Y+1, r25	; 0x01
    18f8:	88 23       	and	r24, r24
    18fa:	09 f0       	breq	.+2      	; 0x18fe <OverflowTimer_8bits_synchrounous+0x98>
    18fc:	c0 cf       	rjmp	.-128    	; 0x187e <OverflowTimer_8bits_synchrounous+0x18>

	 /*Clearing the OCF0 flag*/
	 SET_BIT(MTIMER_TIFR, TIMER_OUTPUT_COMPARE_FLAG_BIT[timerIndex]);
	}

	mtimer_8bits_stop(timerIndex);
    18fe:	8a 81       	ldd	r24, Y+2	; 0x02
    1900:	0e 94 7e 08 	call	0x10fc	; 0x10fc <mtimer_8bits_stop>
	/* pre-scaling value cleared
	 * in timer0 OR timer2 register
	 according to the index inserted*/


}
    1904:	0f 90       	pop	r0
    1906:	0f 90       	pop	r0
    1908:	0f 90       	pop	r0
    190a:	cf 91       	pop	r28
    190c:	df 91       	pop	r29
    190e:	08 95       	ret

00001910 <OverflowTimer_8bits_Asynchrounous>:
/********************************************  8BIT TIMER  ********************************************************************/

/************************** ID =3.18 ******************************/
void  OverflowTimer_8bits_Asynchrounous(u8_t timerIndex, u8_t au8_delayTime, CallbackFunc_t  p_callback_func){
    1910:	df 93       	push	r29
    1912:	cf 93       	push	r28
    1914:	00 d0       	rcall	.+0      	; 0x1916 <OverflowTimer_8bits_Asynchrounous+0x6>
    1916:	00 d0       	rcall	.+0      	; 0x1918 <OverflowTimer_8bits_Asynchrounous+0x8>
    1918:	cd b7       	in	r28, 0x3d	; 61
    191a:	de b7       	in	r29, 0x3e	; 62
    191c:	89 83       	std	Y+1, r24	; 0x01
    191e:	6a 83       	std	Y+2, r22	; 0x02
    1920:	5c 83       	std	Y+4, r21	; 0x04
    1922:	4b 83       	std	Y+3, r20	; 0x03
					//}
	/***************************************************************************************************************/



	mtimer_8bits_start(timerIndex);
    1924:	89 81       	ldd	r24, Y+1	; 0x01
    1926:	0e 94 66 0b 	call	0x16cc	; 0x16cc <mtimer_8bits_start>
	/* pre-scaling value inserted
	 in timer0 OR timer2 register
	 according to the index inserted*/

	gu8_delayTime[2]= au8_delayTime;
    192a:	8a 81       	ldd	r24, Y+2	; 0x02
    192c:	80 93 41 01 	sts	0x0141, r24

	func_register_8bit_overflow[timerIndex]=p_callback_func;
    1930:	89 81       	ldd	r24, Y+1	; 0x01
    1932:	88 2f       	mov	r24, r24
    1934:	90 e0       	ldi	r25, 0x00	; 0
    1936:	88 0f       	add	r24, r24
    1938:	99 1f       	adc	r25, r25
    193a:	fc 01       	movw	r30, r24
    193c:	ea 5b       	subi	r30, 0xBA	; 186
    193e:	fe 4f       	sbci	r31, 0xFE	; 254
    1940:	8b 81       	ldd	r24, Y+3	; 0x03
    1942:	9c 81       	ldd	r25, Y+4	; 0x04
    1944:	91 83       	std	Z+1, r25	; 0x01
    1946:	80 83       	st	Z, r24
	/* register the callback function to be executed in the ISR
	 * when the interrupt occurs  */

	SET_BIT(MTIMER_TIMSK,TIMER_INTERRUPT_OVERFLOW_ENABLE_BIT[timerIndex]);
    1948:	a9 e5       	ldi	r26, 0x59	; 89
    194a:	b0 e0       	ldi	r27, 0x00	; 0
    194c:	e9 e5       	ldi	r30, 0x59	; 89
    194e:	f0 e0       	ldi	r31, 0x00	; 0
    1950:	80 81       	ld	r24, Z
    1952:	48 2f       	mov	r20, r24
    1954:	89 81       	ldd	r24, Y+1	; 0x01
    1956:	88 2f       	mov	r24, r24
    1958:	90 e0       	ldi	r25, 0x00	; 0
    195a:	fc 01       	movw	r30, r24
    195c:	ed 5f       	subi	r30, 0xFD	; 253
    195e:	fe 4f       	sbci	r31, 0xFE	; 254
    1960:	80 81       	ld	r24, Z
    1962:	28 2f       	mov	r18, r24
    1964:	30 e0       	ldi	r19, 0x00	; 0
    1966:	81 e0       	ldi	r24, 0x01	; 1
    1968:	90 e0       	ldi	r25, 0x00	; 0
    196a:	02 2e       	mov	r0, r18
    196c:	02 c0       	rjmp	.+4      	; 0x1972 <OverflowTimer_8bits_Asynchrounous+0x62>
    196e:	88 0f       	add	r24, r24
    1970:	99 1f       	adc	r25, r25
    1972:	0a 94       	dec	r0
    1974:	e2 f7       	brpl	.-8      	; 0x196e <OverflowTimer_8bits_Asynchrounous+0x5e>
    1976:	84 2b       	or	r24, r20
    1978:	8c 93       	st	X, r24


}
    197a:	0f 90       	pop	r0
    197c:	0f 90       	pop	r0
    197e:	0f 90       	pop	r0
    1980:	0f 90       	pop	r0
    1982:	cf 91       	pop	r28
    1984:	df 91       	pop	r29
    1986:	08 95       	ret

00001988 <OverflowTimer_16bits_Init>:


/********************************************  16BIT TIMER  ********************************************************************/

/************************** ID =3.19 ******************************/
void OverflowTimer_16bits_Init(mtimerPrescaler_t Prescaler){
    1988:	df 93       	push	r29
    198a:	cf 93       	push	r28
    198c:	0f 92       	push	r0
    198e:	cd b7       	in	r28, 0x3d	; 61
    1990:	de b7       	in	r29, 0x3e	; 62
    1992:	89 83       	std	Y+1, r24	; 0x01


	 MTIMER_TCCR1A &= ~(TCCR1A_WAVE_GENERATION_PWM10) & ~(TCCR1A_WAVE_GENERATION_PWM11);
    1994:	af e4       	ldi	r26, 0x4F	; 79
    1996:	b0 e0       	ldi	r27, 0x00	; 0
    1998:	ef e4       	ldi	r30, 0x4F	; 79
    199a:	f0 e0       	ldi	r31, 0x00	; 0
    199c:	80 81       	ld	r24, Z
    199e:	8e 7f       	andi	r24, 0xFE	; 254
    19a0:	8c 93       	st	X, r24

	 MTIMER_TCCR1B |= (TCCR1B_WAVE_GENERATION_12);
    19a2:	ae e4       	ldi	r26, 0x4E	; 78
    19a4:	b0 e0       	ldi	r27, 0x00	; 0
    19a6:	ee e4       	ldi	r30, 0x4E	; 78
    19a8:	f0 e0       	ldi	r31, 0x00	; 0
    19aa:	80 81       	ld	r24, Z
    19ac:	83 60       	ori	r24, 0x03	; 3
    19ae:	8c 93       	st	X, r24
	 MTIMER_TCCR1B &= ~(TCCR1B_WAVE_GENERATION_13);
    19b0:	ae e4       	ldi	r26, 0x4E	; 78
    19b2:	b0 e0       	ldi	r27, 0x00	; 0
    19b4:	ee e4       	ldi	r30, 0x4E	; 78
    19b6:	f0 e0       	ldi	r31, 0x00	; 0
    19b8:	80 81       	ld	r24, Z
    19ba:	8b 7f       	andi	r24, 0xFB	; 251
    19bc:	8c 93       	st	X, r24

	 gu8_timer_16bits_SelectedPrescaler1= Prescaler;
    19be:	89 81       	ldd	r24, Y+1	; 0x01
    19c0:	80 93 3c 01 	sts	0x013C, r24
    /* insert the pre-scaler value in a global variable   */

	 MTIMER_TCCR1A &= ~(TCCR1A_FORCE_OUTPUT_COMPARE_CHANNELA);
    19c4:	af e4       	ldi	r26, 0x4F	; 79
    19c6:	b0 e0       	ldi	r27, 0x00	; 0
    19c8:	ef e4       	ldi	r30, 0x4F	; 79
    19ca:	f0 e0       	ldi	r31, 0x00	; 0
    19cc:	80 81       	ld	r24, Z
    19ce:	8c 7f       	andi	r24, 0xFC	; 252
    19d0:	8c 93       	st	X, r24
	 /* non-pwm modes  */

	 MTIMER_TCCR1A &= ~(1<<TCCR1A_COMPARE_OUTPUT_CHANNELA1) & ~(TCCR1A_COMPARE_OUTPUT_CHANNELA0);
    19d2:	af e4       	ldi	r26, 0x4F	; 79
    19d4:	b0 e0       	ldi	r27, 0x00	; 0
    19d6:	ef e4       	ldi	r30, 0x4F	; 79
    19d8:	f0 e0       	ldi	r31, 0x00	; 0
    19da:	80 81       	ld	r24, Z
    19dc:	89 77       	andi	r24, 0x79	; 121
    19de:	8c 93       	st	X, r24
	 /* No need to connect the OC1A in the overflow and the delay mode
	  it will be connected in the PWM mode because in the delay mode
	  it will not give an interrupt every time there is a compare match  */

 }
    19e0:	0f 90       	pop	r0
    19e2:	cf 91       	pop	r28
    19e4:	df 91       	pop	r29
    19e6:	08 95       	ret

000019e8 <OverflowTimer_16bits_Asynchrounous>:
  * In Asynchrounous function the 8bit timer is stopped NOT inside the function
  * but INSIDE the ISR block after the func_register_8bit_overflow[timerIndex]() is executed
  */
 /****************************************************************************************/
/************************** ID =3.20 ******************************/
void  OverflowTimer_16bits_Asynchrounous(u8_t Number_OverFlows, CallbackFunc_t  p_callback_func){
    19e8:	df 93       	push	r29
    19ea:	cf 93       	push	r28
    19ec:	00 d0       	rcall	.+0      	; 0x19ee <OverflowTimer_16bits_Asynchrounous+0x6>
    19ee:	0f 92       	push	r0
    19f0:	cd b7       	in	r28, 0x3d	; 61
    19f2:	de b7       	in	r29, 0x3e	; 62
    19f4:	89 83       	std	Y+1, r24	; 0x01
    19f6:	7b 83       	std	Y+3, r23	; 0x03
    19f8:	6a 83       	std	Y+2, r22	; 0x02

	 mtimer_16bits_start();
    19fa:	0e 94 15 0d 	call	0x1a2a	; 0x1a2a <mtimer_16bits_start>

	 Number_OverFlows_16bit_Timer = Number_OverFlows;
    19fe:	89 81       	ldd	r24, Y+1	; 0x01
    1a00:	80 93 41 01 	sts	0x0141, r24

	 func_register_16bit_timer1[TIMER1_OVF] = p_callback_func;
    1a04:	8a 81       	ldd	r24, Y+2	; 0x02
    1a06:	9b 81       	ldd	r25, Y+3	; 0x03
    1a08:	90 93 4f 01 	sts	0x014F, r25
    1a0c:	80 93 4e 01 	sts	0x014E, r24

	 SET_BIT(MTIMER_TIMSK,OVERFLOW_INTERRUPT_ENABLE1);
    1a10:	a9 e5       	ldi	r26, 0x59	; 89
    1a12:	b0 e0       	ldi	r27, 0x00	; 0
    1a14:	e9 e5       	ldi	r30, 0x59	; 89
    1a16:	f0 e0       	ldi	r31, 0x00	; 0
    1a18:	80 81       	ld	r24, Z
    1a1a:	84 60       	ori	r24, 0x04	; 4
    1a1c:	8c 93       	st	X, r24

 }
    1a1e:	0f 90       	pop	r0
    1a20:	0f 90       	pop	r0
    1a22:	0f 90       	pop	r0
    1a24:	cf 91       	pop	r28
    1a26:	df 91       	pop	r29
    1a28:	08 95       	ret

00001a2a <mtimer_16bits_start>:
	/*Return from this function*/
	return;
}

/************************** ID =3.3 ******************************/
void static inline mtimer_16bits_start(void){
    1a2a:	df 93       	push	r29
    1a2c:	cf 93       	push	r28
    1a2e:	cd b7       	in	r28, 0x3d	; 61
    1a30:	de b7       	in	r29, 0x3e	; 62

	/*Resetting timer counter1*/
	MTIMER_TCNT1 =0;
    1a32:	ec e4       	ldi	r30, 0x4C	; 76
    1a34:	f0 e0       	ldi	r31, 0x00	; 0
    1a36:	11 82       	std	Z+1, r1	; 0x01
    1a38:	10 82       	st	Z, r1

	MTIMER_TCCR1B &= ~(TCCR1B_CLOCK_SELECT_10) & ~(TCCR1B_CLOCK_SELECT_11) & ~(TCCR1B_CLOCK_SELECT_12);
    1a3a:	ae e4       	ldi	r26, 0x4E	; 78
    1a3c:	b0 e0       	ldi	r27, 0x00	; 0
    1a3e:	ee e4       	ldi	r30, 0x4E	; 78
    1a40:	f0 e0       	ldi	r31, 0x00	; 0
    1a42:	80 81       	ld	r24, Z
    1a44:	8c 7f       	andi	r24, 0xFC	; 252
    1a46:	8c 93       	st	X, r24

	MTIMER_TCCR1B |= gu8_timer_16bits_SelectedPrescaler1;
    1a48:	ae e4       	ldi	r26, 0x4E	; 78
    1a4a:	b0 e0       	ldi	r27, 0x00	; 0
    1a4c:	ee e4       	ldi	r30, 0x4E	; 78
    1a4e:	f0 e0       	ldi	r31, 0x00	; 0
    1a50:	90 81       	ld	r25, Z
    1a52:	80 91 3c 01 	lds	r24, 0x013C
    1a56:	89 2b       	or	r24, r25
    1a58:	8c 93       	st	X, r24

}
    1a5a:	cf 91       	pop	r28
    1a5c:	df 91       	pop	r29
    1a5e:	08 95       	ret

00001a60 <OverflowTimer_16bits_synchrounous>:

	 SET_BIT(MTIMER_TIMSK,OVERFLOW_INTERRUPT_ENABLE1);

 }
/************************** ID =3.21 ******************************/
 void  OverflowTimer_16bits_synchrounous(u8_t NumberOverFlows_sync){
    1a60:	df 93       	push	r29
    1a62:	cf 93       	push	r28
    1a64:	00 d0       	rcall	.+0      	; 0x1a66 <OverflowTimer_16bits_synchrounous+0x6>
    1a66:	cd b7       	in	r28, 0x3d	; 61
    1a68:	de b7       	in	r29, 0x3e	; 62
    1a6a:	89 83       	std	Y+1, r24	; 0x01

	 mtimer_16bits_start();
    1a6c:	0e 94 15 0d 	call	0x1a2a	; 0x1a2a <mtimer_16bits_start>
    1a70:	12 c0       	rjmp	.+36     	; 0x1a96 <OverflowTimer_16bits_synchrounous+0x36>

	 while(NumberOverFlows_sync--){
			  while( 0 == GET_BIT(MTIMER_TIFR,TIMER1_OVERFLOW_FLAG));
    1a72:	e8 e5       	ldi	r30, 0x58	; 88
    1a74:	f0 e0       	ldi	r31, 0x00	; 0
    1a76:	80 81       	ld	r24, Z
    1a78:	86 95       	lsr	r24
    1a7a:	86 95       	lsr	r24
    1a7c:	88 2f       	mov	r24, r24
    1a7e:	90 e0       	ldi	r25, 0x00	; 0
    1a80:	81 70       	andi	r24, 0x01	; 1
    1a82:	90 70       	andi	r25, 0x00	; 0
    1a84:	00 97       	sbiw	r24, 0x00	; 0
    1a86:	a9 f3       	breq	.-22     	; 0x1a72 <OverflowTimer_16bits_synchrounous+0x12>

			  SET_BIT(MTIMER_TIFR,TIMER1_OVERFLOW_FLAG);
    1a88:	a8 e5       	ldi	r26, 0x58	; 88
    1a8a:	b0 e0       	ldi	r27, 0x00	; 0
    1a8c:	e8 e5       	ldi	r30, 0x58	; 88
    1a8e:	f0 e0       	ldi	r31, 0x00	; 0
    1a90:	80 81       	ld	r24, Z
    1a92:	84 60       	ori	r24, 0x04	; 4
    1a94:	8c 93       	st	X, r24
/************************** ID =3.21 ******************************/
 void  OverflowTimer_16bits_synchrounous(u8_t NumberOverFlows_sync){

	 mtimer_16bits_start();

	 while(NumberOverFlows_sync--){
    1a96:	89 81       	ldd	r24, Y+1	; 0x01
    1a98:	8a 83       	std	Y+2, r24	; 0x02
    1a9a:	8a 81       	ldd	r24, Y+2	; 0x02
    1a9c:	88 23       	and	r24, r24
    1a9e:	11 f0       	breq	.+4      	; 0x1aa4 <OverflowTimer_16bits_synchrounous+0x44>
    1aa0:	81 e0       	ldi	r24, 0x01	; 1
    1aa2:	8a 83       	std	Y+2, r24	; 0x02
    1aa4:	8a 81       	ldd	r24, Y+2	; 0x02
    1aa6:	99 81       	ldd	r25, Y+1	; 0x01
    1aa8:	91 50       	subi	r25, 0x01	; 1
    1aaa:	99 83       	std	Y+1, r25	; 0x01
    1aac:	88 23       	and	r24, r24
    1aae:	09 f7       	brne	.-62     	; 0x1a72 <OverflowTimer_16bits_synchrounous+0x12>
			  while( 0 == GET_BIT(MTIMER_TIFR,TIMER1_OVERFLOW_FLAG));

			  SET_BIT(MTIMER_TIFR,TIMER1_OVERFLOW_FLAG);
		 }

	 mtimer_16bits_stop();
    1ab0:	0e 94 db 09 	call	0x13b6	; 0x13b6 <mtimer_16bits_stop>
 }
    1ab4:	0f 90       	pop	r0
    1ab6:	0f 90       	pop	r0
    1ab8:	cf 91       	pop	r28
    1aba:	df 91       	pop	r29
    1abc:	08 95       	ret

00001abe <Global_Interrupt_Enable>:

 void Global_Interrupt_Enable(void){
    1abe:	df 93       	push	r29
    1ac0:	cf 93       	push	r28
    1ac2:	cd b7       	in	r28, 0x3d	; 61
    1ac4:	de b7       	in	r29, 0x3e	; 62
	 SET_BIT(MTIMER_SREG,7);
    1ac6:	af e5       	ldi	r26, 0x5F	; 95
    1ac8:	b0 e0       	ldi	r27, 0x00	; 0
    1aca:	ef e5       	ldi	r30, 0x5F	; 95
    1acc:	f0 e0       	ldi	r31, 0x00	; 0
    1ace:	80 81       	ld	r24, Z
    1ad0:	80 68       	ori	r24, 0x80	; 128
    1ad2:	8c 93       	st	X, r24
 }
    1ad4:	cf 91       	pop	r28
    1ad6:	df 91       	pop	r29
    1ad8:	08 95       	ret

00001ada <Disable_Interrupt_Enable>:

 void Disable_Interrupt_Enable(void){
    1ada:	df 93       	push	r29
    1adc:	cf 93       	push	r28
    1ade:	cd b7       	in	r28, 0x3d	; 61
    1ae0:	de b7       	in	r29, 0x3e	; 62
	 CLEAR_BIT(MTIMER_SREG,7);
    1ae2:	af e5       	ldi	r26, 0x5F	; 95
    1ae4:	b0 e0       	ldi	r27, 0x00	; 0
    1ae6:	ef e5       	ldi	r30, 0x5F	; 95
    1ae8:	f0 e0       	ldi	r31, 0x00	; 0
    1aea:	80 81       	ld	r24, Z
    1aec:	8f 77       	andi	r24, 0x7F	; 127
    1aee:	8c 93       	st	X, r24
 }
    1af0:	cf 91       	pop	r28
    1af2:	df 91       	pop	r29
    1af4:	08 95       	ret

00001af6 <Icu_init>:
/****************************************************************************************************************/
/********************************************  ICU MODE *********************************************************/
/****************************************************************************************************************/

/****************************************************************************************************************/
void  Icu_init( ICU_Config_t * ptr_icu_config){
    1af6:	df 93       	push	r29
    1af8:	cf 93       	push	r28
    1afa:	00 d0       	rcall	.+0      	; 0x1afc <Icu_init+0x6>
    1afc:	cd b7       	in	r28, 0x3d	; 61
    1afe:	de b7       	in	r29, 0x3e	; 62
    1b00:	9a 83       	std	Y+2, r25	; 0x02
    1b02:	89 83       	std	Y+1, r24	; 0x01

      /* NORMAL MODE the timer counts till 65,536  */
	  MTIMER_TCCR1A |= (TCCR1A_FORCE_OUTPUT_COMPARE_CHANNELB)|(TCCR1A_FORCE_OUTPUT_COMPARE_CHANNELA) ;
    1b04:	af e4       	ldi	r26, 0x4F	; 79
    1b06:	b0 e0       	ldi	r27, 0x00	; 0
    1b08:	ef e4       	ldi	r30, 0x4F	; 79
    1b0a:	f0 e0       	ldi	r31, 0x00	; 0
    1b0c:	80 81       	ld	r24, Z
    1b0e:	83 60       	ori	r24, 0x03	; 3
    1b10:	8c 93       	st	X, r24

	  MTIMER_TCCR1B = ( (MTIMER_TCCR1B & 0xF8)|  (ptr_icu_config ->prescaler));
    1b12:	ae e4       	ldi	r26, 0x4E	; 78
    1b14:	b0 e0       	ldi	r27, 0x00	; 0
    1b16:	ee e4       	ldi	r30, 0x4E	; 78
    1b18:	f0 e0       	ldi	r31, 0x00	; 0
    1b1a:	80 81       	ld	r24, Z
    1b1c:	98 2f       	mov	r25, r24
    1b1e:	98 7f       	andi	r25, 0xF8	; 248
    1b20:	e9 81       	ldd	r30, Y+1	; 0x01
    1b22:	fa 81       	ldd	r31, Y+2	; 0x02
    1b24:	81 81       	ldd	r24, Z+1	; 0x01
    1b26:	89 2b       	or	r24, r25
    1b28:	8c 93       	st	X, r24

	  MTIMER_TCCR1B = ( (MTIMER_TCCR1B & 0xBF)|  ((ptr_icu_config->edge)<<TCCR1B_Input_Capture_Edge_Select) );
    1b2a:	ae e4       	ldi	r26, 0x4E	; 78
    1b2c:	b0 e0       	ldi	r27, 0x00	; 0
    1b2e:	ee e4       	ldi	r30, 0x4E	; 78
    1b30:	f0 e0       	ldi	r31, 0x00	; 0
    1b32:	80 81       	ld	r24, Z
    1b34:	28 2f       	mov	r18, r24
    1b36:	2f 7b       	andi	r18, 0xBF	; 191
    1b38:	e9 81       	ldd	r30, Y+1	; 0x01
    1b3a:	fa 81       	ldd	r31, Y+2	; 0x02
    1b3c:	80 81       	ld	r24, Z
    1b3e:	88 2f       	mov	r24, r24
    1b40:	90 e0       	ldi	r25, 0x00	; 0
    1b42:	00 24       	eor	r0, r0
    1b44:	96 95       	lsr	r25
    1b46:	87 95       	ror	r24
    1b48:	07 94       	ror	r0
    1b4a:	96 95       	lsr	r25
    1b4c:	87 95       	ror	r24
    1b4e:	07 94       	ror	r0
    1b50:	98 2f       	mov	r25, r24
    1b52:	80 2d       	mov	r24, r0
    1b54:	82 2b       	or	r24, r18
    1b56:	8c 93       	st	X, r24
	  /* Insert the required edge and pre-scaling  */

	  MTIMER_TCNT1 = 0;
    1b58:	ec e4       	ldi	r30, 0x4C	; 76
    1b5a:	f0 e0       	ldi	r31, 0x00	; 0
    1b5c:	11 82       	std	Z+1, r1	; 0x01
    1b5e:	10 82       	st	Z, r1

	  MTIMER_ICR1=0;
    1b60:	e6 e4       	ldi	r30, 0x46	; 70
    1b62:	f0 e0       	ldi	r31, 0x00	; 0
    1b64:	11 82       	std	Z+1, r1	; 0x01
    1b66:	10 82       	st	Z, r1

	  /* Enable the Input Capture interrupt to generate an interrupt when edge is detected on ICP1/PD6 pin */
	  MTIMER_TIMSK |=(1<<5);
    1b68:	a9 e5       	ldi	r26, 0x59	; 89
    1b6a:	b0 e0       	ldi	r27, 0x00	; 0
    1b6c:	e9 e5       	ldi	r30, 0x59	; 89
    1b6e:	f0 e0       	ldi	r31, 0x00	; 0
    1b70:	80 81       	ld	r24, Z
    1b72:	80 62       	ori	r24, 0x20	; 32
    1b74:	8c 93       	st	X, r24

	  MTIMER_SREG=(1<<7);
    1b76:	ef e5       	ldi	r30, 0x5F	; 95
    1b78:	f0 e0       	ldi	r31, 0x00	; 0
    1b7a:	80 e8       	ldi	r24, 0x80	; 128
    1b7c:	80 83       	st	Z, r24

}
    1b7e:	0f 90       	pop	r0
    1b80:	0f 90       	pop	r0
    1b82:	cf 91       	pop	r28
    1b84:	df 91       	pop	r29
    1b86:	08 95       	ret

00001b88 <Icu_setEdgeDetectionType>:
/****************************************************************************************************************/
void  Icu_setEdgeDetectionType( icu_Edge_t edge){
    1b88:	df 93       	push	r29
    1b8a:	cf 93       	push	r28
    1b8c:	0f 92       	push	r0
    1b8e:	cd b7       	in	r28, 0x3d	; 61
    1b90:	de b7       	in	r29, 0x3e	; 62
    1b92:	89 83       	std	Y+1, r24	; 0x01

	MTIMER_TCCR1B =( (MTIMER_TCCR1B & 0xBF) | ( edge << TCCR1B_Input_Capture_Edge_Select ) );
    1b94:	ae e4       	ldi	r26, 0x4E	; 78
    1b96:	b0 e0       	ldi	r27, 0x00	; 0
    1b98:	ee e4       	ldi	r30, 0x4E	; 78
    1b9a:	f0 e0       	ldi	r31, 0x00	; 0
    1b9c:	80 81       	ld	r24, Z
    1b9e:	28 2f       	mov	r18, r24
    1ba0:	2f 7b       	andi	r18, 0xBF	; 191
    1ba2:	89 81       	ldd	r24, Y+1	; 0x01
    1ba4:	88 2f       	mov	r24, r24
    1ba6:	90 e0       	ldi	r25, 0x00	; 0
    1ba8:	00 24       	eor	r0, r0
    1baa:	96 95       	lsr	r25
    1bac:	87 95       	ror	r24
    1bae:	07 94       	ror	r0
    1bb0:	96 95       	lsr	r25
    1bb2:	87 95       	ror	r24
    1bb4:	07 94       	ror	r0
    1bb6:	98 2f       	mov	r25, r24
    1bb8:	80 2d       	mov	r24, r0
    1bba:	82 2b       	or	r24, r18
    1bbc:	8c 93       	st	X, r24
	/*
	 * insert the required edge type in ICES1 bit in TCCR1B Register
	 */
}
    1bbe:	0f 90       	pop	r0
    1bc0:	cf 91       	pop	r28
    1bc2:	df 91       	pop	r29
    1bc4:	08 95       	ret

00001bc6 <Icu_getInputCaptureValue>:
/****************************************************************************************************************/
 u16_t  Icu_getInputCaptureValue(void){
    1bc6:	df 93       	push	r29
    1bc8:	cf 93       	push	r28
    1bca:	cd b7       	in	r28, 0x3d	; 61
    1bcc:	de b7       	in	r29, 0x3e	; 62

	 return MTIMER_ICR1;
    1bce:	e6 e4       	ldi	r30, 0x46	; 70
    1bd0:	f0 e0       	ldi	r31, 0x00	; 0
    1bd2:	80 81       	ld	r24, Z
    1bd4:	91 81       	ldd	r25, Z+1	; 0x01

}
    1bd6:	cf 91       	pop	r28
    1bd8:	df 91       	pop	r29
    1bda:	08 95       	ret

00001bdc <Icu_DeInit>:
/******************************************** STOPPING ICU DRIVER  ********************************************************************/
void Icu_DeInit(void){
    1bdc:	df 93       	push	r29
    1bde:	cf 93       	push	r28
    1be0:	cd b7       	in	r28, 0x3d	; 61
    1be2:	de b7       	in	r29, 0x3e	; 62

	MTIMER_TCCR1A=0;
    1be4:	ef e4       	ldi	r30, 0x4F	; 79
    1be6:	f0 e0       	ldi	r31, 0x00	; 0
    1be8:	10 82       	st	Z, r1
	MTIMER_TCCR1B=0;
    1bea:	ee e4       	ldi	r30, 0x4E	; 78
    1bec:	f0 e0       	ldi	r31, 0x00	; 0
    1bee:	10 82       	st	Z, r1

	MTIMER_TCNT1=0;
    1bf0:	ec e4       	ldi	r30, 0x4C	; 76
    1bf2:	f0 e0       	ldi	r31, 0x00	; 0
    1bf4:	11 82       	std	Z+1, r1	; 0x01
    1bf6:	10 82       	st	Z, r1
	MTIMER_OCR1A=0;
    1bf8:	ea e4       	ldi	r30, 0x4A	; 74
    1bfa:	f0 e0       	ldi	r31, 0x00	; 0
    1bfc:	11 82       	std	Z+1, r1	; 0x01
    1bfe:	10 82       	st	Z, r1
	MTIMER_OCR1B=0;
    1c00:	e8 e4       	ldi	r30, 0x48	; 72
    1c02:	f0 e0       	ldi	r31, 0x00	; 0
    1c04:	11 82       	std	Z+1, r1	; 0x01
    1c06:	10 82       	st	Z, r1
	MTIMER_ICR1=0;
    1c08:	e6 e4       	ldi	r30, 0x46	; 70
    1c0a:	f0 e0       	ldi	r31, 0x00	; 0
    1c0c:	11 82       	std	Z+1, r1	; 0x01
    1c0e:	10 82       	st	Z, r1

	MTIMER_TIMSK=(0<<5);
    1c10:	e9 e5       	ldi	r30, 0x59	; 89
    1c12:	f0 e0       	ldi	r31, 0x00	; 0
    1c14:	10 82       	st	Z, r1
/* clear  the bit responsible for the interrupt enable */
	/* Disable the icu driver  */
}
    1c16:	cf 91       	pop	r28
    1c18:	df 91       	pop	r29
    1c1a:	08 95       	ret

00001c1c <Icu_clearTimerValue>:

/****************************************************************************************************************/
 void  Icu_clearTimerValue(void){
    1c1c:	df 93       	push	r29
    1c1e:	cf 93       	push	r28
    1c20:	cd b7       	in	r28, 0x3d	; 61
    1c22:	de b7       	in	r29, 0x3e	; 62
	 MTIMER_TCNT1=0;
    1c24:	ec e4       	ldi	r30, 0x4C	; 76
    1c26:	f0 e0       	ldi	r31, 0x00	; 0
    1c28:	11 82       	std	Z+1, r1	; 0x01
    1c2a:	10 82       	st	Z, r1
}
    1c2c:	cf 91       	pop	r28
    1c2e:	df 91       	pop	r29
    1c30:	08 95       	ret

00001c32 <RegisterCallback_8Bit_Overflow>:

/***********************************************************************************************************************/

 void RegisterCallback_8Bit_Overflow(u8_t function_id, CallbackFunc_t  p_callback_func ) {
    1c32:	df 93       	push	r29
    1c34:	cf 93       	push	r28
    1c36:	00 d0       	rcall	.+0      	; 0x1c38 <RegisterCallback_8Bit_Overflow+0x6>
    1c38:	0f 92       	push	r0
    1c3a:	cd b7       	in	r28, 0x3d	; 61
    1c3c:	de b7       	in	r29, 0x3e	; 62
    1c3e:	89 83       	std	Y+1, r24	; 0x01
    1c40:	7b 83       	std	Y+3, r23	; 0x03
    1c42:	6a 83       	std	Y+2, r22	; 0x02

	 func_register_8bit_overflow[function_id] = p_callback_func;
    1c44:	89 81       	ldd	r24, Y+1	; 0x01
    1c46:	88 2f       	mov	r24, r24
    1c48:	90 e0       	ldi	r25, 0x00	; 0
    1c4a:	88 0f       	add	r24, r24
    1c4c:	99 1f       	adc	r25, r25
    1c4e:	fc 01       	movw	r30, r24
    1c50:	ea 5b       	subi	r30, 0xBA	; 186
    1c52:	fe 4f       	sbci	r31, 0xFE	; 254
    1c54:	8a 81       	ldd	r24, Y+2	; 0x02
    1c56:	9b 81       	ldd	r25, Y+3	; 0x03
    1c58:	91 83       	std	Z+1, r25	; 0x01
    1c5a:	80 83       	st	Z, r24
  }
    1c5c:	0f 90       	pop	r0
    1c5e:	0f 90       	pop	r0
    1c60:	0f 90       	pop	r0
    1c62:	cf 91       	pop	r28
    1c64:	df 91       	pop	r29
    1c66:	08 95       	ret

00001c68 <RegisterCallback_8Bit_Compare>:
/* insert the required callback function in the pointer to function --> func_register_8bit_overflow[function_id]    */


 void RegisterCallback_8Bit_Compare(u8_t function_id, CallbackFunc_t  p_callback_func ) {
    1c68:	df 93       	push	r29
    1c6a:	cf 93       	push	r28
    1c6c:	00 d0       	rcall	.+0      	; 0x1c6e <RegisterCallback_8Bit_Compare+0x6>
    1c6e:	0f 92       	push	r0
    1c70:	cd b7       	in	r28, 0x3d	; 61
    1c72:	de b7       	in	r29, 0x3e	; 62
    1c74:	89 83       	std	Y+1, r24	; 0x01
    1c76:	7b 83       	std	Y+3, r23	; 0x03
    1c78:	6a 83       	std	Y+2, r22	; 0x02

	 func_register_8bit_compare[function_id] = p_callback_func;
    1c7a:	89 81       	ldd	r24, Y+1	; 0x01
    1c7c:	88 2f       	mov	r24, r24
    1c7e:	90 e0       	ldi	r25, 0x00	; 0
    1c80:	88 0f       	add	r24, r24
    1c82:	99 1f       	adc	r25, r25
    1c84:	fc 01       	movw	r30, r24
    1c86:	e6 5b       	subi	r30, 0xB6	; 182
    1c88:	fe 4f       	sbci	r31, 0xFE	; 254
    1c8a:	8a 81       	ldd	r24, Y+2	; 0x02
    1c8c:	9b 81       	ldd	r25, Y+3	; 0x03
    1c8e:	91 83       	std	Z+1, r25	; 0x01
    1c90:	80 83       	st	Z, r24
  }
    1c92:	0f 90       	pop	r0
    1c94:	0f 90       	pop	r0
    1c96:	0f 90       	pop	r0
    1c98:	cf 91       	pop	r28
    1c9a:	df 91       	pop	r29
    1c9c:	08 95       	ret

00001c9e <RegisterCallback_16Bit_Timer1>:
/* insert the required callback function in the pointer to function --> func_register_8bit_compare[function_id]   */


 void RegisterCallback_16Bit_Timer1(u8_t function_id, CallbackFunc_t  p_callback_func ) {
    1c9e:	df 93       	push	r29
    1ca0:	cf 93       	push	r28
    1ca2:	00 d0       	rcall	.+0      	; 0x1ca4 <RegisterCallback_16Bit_Timer1+0x6>
    1ca4:	0f 92       	push	r0
    1ca6:	cd b7       	in	r28, 0x3d	; 61
    1ca8:	de b7       	in	r29, 0x3e	; 62
    1caa:	89 83       	std	Y+1, r24	; 0x01
    1cac:	7b 83       	std	Y+3, r23	; 0x03
    1cae:	6a 83       	std	Y+2, r22	; 0x02

	 func_register_16bit_timer1[function_id] = p_callback_func;
    1cb0:	89 81       	ldd	r24, Y+1	; 0x01
    1cb2:	88 2f       	mov	r24, r24
    1cb4:	90 e0       	ldi	r25, 0x00	; 0
    1cb6:	88 0f       	add	r24, r24
    1cb8:	99 1f       	adc	r25, r25
    1cba:	fc 01       	movw	r30, r24
    1cbc:	e2 5b       	subi	r30, 0xB2	; 178
    1cbe:	fe 4f       	sbci	r31, 0xFE	; 254
    1cc0:	8a 81       	ldd	r24, Y+2	; 0x02
    1cc2:	9b 81       	ldd	r25, Y+3	; 0x03
    1cc4:	91 83       	std	Z+1, r25	; 0x01
    1cc6:	80 83       	st	Z, r24
  }
    1cc8:	0f 90       	pop	r0
    1cca:	0f 90       	pop	r0
    1ccc:	0f 90       	pop	r0
    1cce:	cf 91       	pop	r28
    1cd0:	df 91       	pop	r29
    1cd2:	08 95       	ret

00001cd4 <itoa>:
    1cd4:	fb 01       	movw	r30, r22
    1cd6:	9f 01       	movw	r18, r30
    1cd8:	e8 94       	clt
    1cda:	42 30       	cpi	r20, 0x02	; 2
    1cdc:	c4 f0       	brlt	.+48     	; 0x1d0e <itoa+0x3a>
    1cde:	45 32       	cpi	r20, 0x25	; 37
    1ce0:	b4 f4       	brge	.+44     	; 0x1d0e <itoa+0x3a>
    1ce2:	4a 30       	cpi	r20, 0x0A	; 10
    1ce4:	29 f4       	brne	.+10     	; 0x1cf0 <itoa+0x1c>
    1ce6:	97 fb       	bst	r25, 7
    1ce8:	1e f4       	brtc	.+6      	; 0x1cf0 <itoa+0x1c>
    1cea:	90 95       	com	r25
    1cec:	81 95       	neg	r24
    1cee:	9f 4f       	sbci	r25, 0xFF	; 255
    1cf0:	64 2f       	mov	r22, r20
    1cf2:	77 27       	eor	r23, r23
    1cf4:	0e 94 9b 0e 	call	0x1d36	; 0x1d36 <__udivmodhi4>
    1cf8:	80 5d       	subi	r24, 0xD0	; 208
    1cfa:	8a 33       	cpi	r24, 0x3A	; 58
    1cfc:	0c f0       	brlt	.+2      	; 0x1d00 <itoa+0x2c>
    1cfe:	89 5d       	subi	r24, 0xD9	; 217
    1d00:	81 93       	st	Z+, r24
    1d02:	cb 01       	movw	r24, r22
    1d04:	00 97       	sbiw	r24, 0x00	; 0
    1d06:	a1 f7       	brne	.-24     	; 0x1cf0 <itoa+0x1c>
    1d08:	16 f4       	brtc	.+4      	; 0x1d0e <itoa+0x3a>
    1d0a:	5d e2       	ldi	r21, 0x2D	; 45
    1d0c:	51 93       	st	Z+, r21
    1d0e:	10 82       	st	Z, r1
    1d10:	c9 01       	movw	r24, r18
    1d12:	0c 94 8b 0e 	jmp	0x1d16	; 0x1d16 <strrev>

00001d16 <strrev>:
    1d16:	dc 01       	movw	r26, r24
    1d18:	fc 01       	movw	r30, r24
    1d1a:	67 2f       	mov	r22, r23
    1d1c:	71 91       	ld	r23, Z+
    1d1e:	77 23       	and	r23, r23
    1d20:	e1 f7       	brne	.-8      	; 0x1d1a <strrev+0x4>
    1d22:	32 97       	sbiw	r30, 0x02	; 2
    1d24:	04 c0       	rjmp	.+8      	; 0x1d2e <strrev+0x18>
    1d26:	7c 91       	ld	r23, X
    1d28:	6d 93       	st	X+, r22
    1d2a:	70 83       	st	Z, r23
    1d2c:	62 91       	ld	r22, -Z
    1d2e:	ae 17       	cp	r26, r30
    1d30:	bf 07       	cpc	r27, r31
    1d32:	c8 f3       	brcs	.-14     	; 0x1d26 <strrev+0x10>
    1d34:	08 95       	ret

00001d36 <__udivmodhi4>:
    1d36:	aa 1b       	sub	r26, r26
    1d38:	bb 1b       	sub	r27, r27
    1d3a:	51 e1       	ldi	r21, 0x11	; 17
    1d3c:	07 c0       	rjmp	.+14     	; 0x1d4c <__udivmodhi4_ep>

00001d3e <__udivmodhi4_loop>:
    1d3e:	aa 1f       	adc	r26, r26
    1d40:	bb 1f       	adc	r27, r27
    1d42:	a6 17       	cp	r26, r22
    1d44:	b7 07       	cpc	r27, r23
    1d46:	10 f0       	brcs	.+4      	; 0x1d4c <__udivmodhi4_ep>
    1d48:	a6 1b       	sub	r26, r22
    1d4a:	b7 0b       	sbc	r27, r23

00001d4c <__udivmodhi4_ep>:
    1d4c:	88 1f       	adc	r24, r24
    1d4e:	99 1f       	adc	r25, r25
    1d50:	5a 95       	dec	r21
    1d52:	a9 f7       	brne	.-22     	; 0x1d3e <__udivmodhi4_loop>
    1d54:	80 95       	com	r24
    1d56:	90 95       	com	r25
    1d58:	bc 01       	movw	r22, r24
    1d5a:	cd 01       	movw	r24, r26
    1d5c:	08 95       	ret

00001d5e <_exit>:
    1d5e:	f8 94       	cli

00001d60 <__stop_program>:
    1d60:	ff cf       	rjmp	.-2      	; 0x1d60 <__stop_program>
